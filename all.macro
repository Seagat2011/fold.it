version: 1
{
 "Example 1: Basic" : "{\n \"action-0\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"Welcome to the recipe editor!  \\\\\\\\\\\\\\\"Recipes\\\\\\\\\\\\\\\"are a way to automate things that you commonly do when playing Foldit.  Each recipe contains a sequence of \\\\\\\\\\\\\\\"steps\\\\\\\\\\\\\\\"; and each step may need you to supply some \\\\\\\\\\\\\\\"ingredients\\\\\\\\\\\\\\\".\\\\\\\\n\\\\\\\\nThis is a basic example recipe that does a shake and then a wiggle.  You can click the Run button to try out the recipe.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-1\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"Each step shows a picture and its name.  Comment steps don't do anything\\\\\\\\\\\\\\\, but they let you write about what's going on in the recipe\\\\\\\\\\\\\\\, to remind yourself\\\\\\\\\\\\\\\, or tell other people who may use it.  The step after this will shake the protein.  It has no extra ingredients.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-2\" : \"{\\n \\\"name\\\" : \\\"shake\\\"\\n}\\n\"\n \"action-3\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"The next step is a wiggle.  It has one ingredient\\\\\\\\\\\\\\\, which is the number of times wiggle should try improving the protein before it goes to the next step.  Here it is set to 1.  It can also be set to run until you stop it.  Try clicking on the box to change the number and see what effect that has when you run!\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-4\" : \"{\\n \\\"name\\\" : \\\"wiggle\\\"\\n \\\"num_of_iterations\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"integer\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"desc\" : \"A basic example that shakes\\\, then wiggles.\"\n \"hidden\" : \"1\"\n \"mid\" : \"1\"\n \"mrid\" : \"1\"\n  \"name\" : \"Example 1: Basic\"\n \"size\" : \"5\"\n \"ver\" : \"0.3\"\n}\n"
 "Example 2: Band Reduce" : "{\n \"action-0\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"This recipes does some wiggles\\\\\\\\\\\\\\\, and reduces the strength of any bands between each wiggle.  So you should set up some bands before using this recipe!\\\\\\\\n\\\\\\\\nThe step that changes the strength of bands has two ingredients.  One is the band strength.  Higher numbers mean the bands will pull harder.  The other is which bands should have there strength changed.  Here\\\\\\\\\\\\\\\, it is set to all bands.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-1\" : \"{\\n \\\"bands\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"bands_all\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"set_strength\\\"\\n \\\"strength\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"real\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"2.016129\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-2\" : \"{\\n \\\"name\\\" : \\\"wiggle\\\"\\n \\\"num_of_iterations\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"integer\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-3\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"Now we reduce the strength of all bands\\\\\\\\\\\\\\\, and wiggle again.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-4\" : \"{\\n \\\"bands\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"bands_all\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"set_strength\\\"\\n \\\"strength\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"real\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"1.048387\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-5\" : \"{\\n \\\"name\\\" : \\\"wiggle\\\"\\n \\\"num_of_iterations\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"integer\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-6\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"And again.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-7\" : \"{\\n \\\"bands\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"bands_all\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"set_strength\\\"\\n \\\"strength\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"real\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"0.483871\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-8\" : \"{\\n \\\"name\\\" : \\\"wiggle\\\"\\n \\\"num_of_iterations\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"integer\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-9\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"We could set the band strength to zero and wiggle one more time to finish up!  Click on the blue dashed boxes to add new steps.  Add the remaining two steps to complete this recipe!\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"desc\" : \"This example does several wiggles in a row\\\, reducing band strength each time.  Set up some rubber bands before running it.\"\n  \"mid\" : \"1\"\n \"mrid\" : \"1\"\n \"name\" : \"Example 2: Band Reduce\"\n \"size\" : \"10\"\n \"ver\" : \"0.3\"\n}\n"
 "Example 3: Compress" : "{\n \"action-0\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"This recipe lets the user pick some segments in the protein\\\\\\\\\\\\\\\, and then sets up bands to pull the rest of the protein in towards them.  The first step removes all the existing bands.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-1\" : \"{\\n \\\"bands\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"bands_all\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"remove\\\"\\n}\\n\"\n \"action-2\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"The next step adds bands.  The add band step takes two ingredients.  Each ingredient is a group of segments.  Bands are added from each of the segments in the first group to each of the segments in the second group.\\\\\\\\n\\\\\\\\nHere\\\\\\\\\\\\\\\, the first group is selected by the user when recupe is used.  The second group is every fifth segment\\\\\\\\\\\\\\\, starting from the first one.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-3\" : \"{\\n \\\"name\\\" : \\\"add_bands\\\"\\n \\\"residues1\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"residues_ref\\\\\\\"\\\\n \\\\\\\"ref-id\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"residues2\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"residues_by_stride\\\\\\\"\\\\n \\\\\\\"start\\\\\\\" : \\\\\\\"{\\\\\\\\n \\\\\\\\\\\\\\\"index\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"is_defined\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"value\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\"\\\\\\\\n \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"single_residue_by_index\\\\\\\\\\\\\\\"\\\\\\\\n}\\\\\\\\n\\\\\\\"\\\\n \\\\\\\"step\\\\\\\" : \\\\\\\"{\\\\\\\\n \\\\\\\\\\\\\\\"is_defined\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\\n \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"integer\\\\\\\\\\\\\\\"\\\\\\\\n \\\\\\\\\\\\\\\"value\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"5\\\\\\\\\\\\\\\"\\\\\\\\n}\\\\\\\\n\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-4\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"Let's reduce the band strength so they don't pull too hard.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-5\" : \"{\\n \\\"bands\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"bands_all\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"set_strength\\\"\\n \\\"strength\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"real\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"0.483871\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-6\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"Next\\\\\\\\\\\\\\\, wiggle until the user decides to stop.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-7\" : \"{\\n \\\"name\\\" : \\\"wiggle\\\"\\n \\\"num_of_iterations\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"integer\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"0\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-8\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"Then we'll remove all the bands we just added\\\\\\\\\\\\\\\, to clean up.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-9\" : \"{\\n \\\"bands\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"bands_all\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"remove\\\"\\n}\\n\"\n \"desc\" : \"This example will allow the user to select some segments and then use bands to compress the protein towards them.\"\n  \"mid\" : \"1\"\n \"mrid\" : \"1\"\n \"name\" : \"Example 3: Compress\"\n \"size\" : \"10\"\n \"ver\" : \"0.3\"\n}\n"
 "Example 4: Local Wiggle" : "{\n \"action-0\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"This recipe will perform a local wiggle on small pieces of the protein.\\\\\\\\n\\\\\\\\nWe start by setting everything to loop.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-1\" : \"{\\n \\\"name\\\" : \\\"set_secondary_structure\\\"\\n \\\"residues\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"residues_all\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"structure\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"structure\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-2\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"Next we unfreeze everything\\\\\\\\\\\\\\\, then freeze every fifth residue\\\\\\\\\\\\\\\, starting from the first.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-3\" : \"{\\n \\\"name\\\" : \\\"unlock\\\"\\n \\\"residues\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"residues_all\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-4\" : \"{\\n \\\"name\\\" : \\\"lock\\\"\\n \\\"residues\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"residues_by_stride\\\\\\\"\\\\n \\\\\\\"start\\\\\\\" : \\\\\\\"{\\\\\\\\n \\\\\\\\\\\\\\\"index\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"is_defined\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"value\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\"\\\\\\\\n \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"single_residue_by_index\\\\\\\\\\\\\\\"\\\\\\\\n}\\\\\\\\n\\\\\\\"\\\\n \\\\\\\"step\\\\\\\" : \\\\\\\"{\\\\\\\\n \\\\\\\\\\\\\\\"is_defined\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\\n \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"integer\\\\\\\\\\\\\\\"\\\\\\\\n \\\\\\\\\\\\\\\"value\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"5\\\\\\\\\\\\\\\"\\\\\\\\n}\\\\\\\\n\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"action-5\" : \"{\\n \\\"comment\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"text\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"Finally\\\\\\\\\\\\\\\, we'll do a  sequence of local wiggles on every fifth residue.  We start from the second residue\\\\\\\\\\\\\\\, that way each local wiggle is started between two locks.\\\\\\\\n\\\\\\\\nEach goes for five iterations\\\\\\\\\\\\\\\, so it has some time to improve things.\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"name\\\" : \\\"comment\\\"\\n}\\n\"\n \"action-6\" : \"{\\n \\\"name\\\" : \\\"local_wiggle\\\"\\n \\\"num_of_iterations\\\" : \\\"{\\\\n \\\\\\\"is_defined\\\\\\\" : \\\\\\\"1\\\\\\\"\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"integer\\\\\\\"\\\\n \\\\\\\"value\\\\\\\" : \\\\\\\"5\\\\\\\"\\\\n}\\\\n\\\"\\n \\\"residues\\\" : \\\"{\\\\n \\\\\\\"name\\\\\\\" : \\\\\\\"residues_by_stride\\\\\\\"\\\\n \\\\\\\"start\\\\\\\" : \\\\\\\"{\\\\\\\\n \\\\\\\\\\\\\\\"index\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"is_defined\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"value\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\"\\\\\\\\n \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"single_residue_by_index\\\\\\\\\\\\\\\"\\\\\\\\n}\\\\\\\\n\\\\\\\"\\\\n \\\\\\\"step\\\\\\\" : \\\\\\\"{\\\\\\\\n \\\\\\\\\\\\\\\"is_defined\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\\n \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"integer\\\\\\\\\\\\\\\"\\\\\\\\n \\\\\\\\\\\\\\\"value\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"5\\\\\\\\\\\\\\\"\\\\\\\\n}\\\\\\\\n\\\\\\\"\\\\n}\\\\n\\\"\\n}\\n\"\n \"desc\" : \"This example does a simple local wiggle walk along the backbone.\"\n  \"mid\" : \"1\"\n \"mrid\" : \"1\"\n \"name\" : \"Example 4: Local Wiggle\"\n \"size\" : \"7\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1042257984" : "{\n \"desc\" : \"Generic Aglorythm on Bands. Changed  length of band generating method.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"28974\"\n \"mrid\" : \"43111\"\n \"name\" : \"GA Bands 2.5  loss\"\n \"parent\" : \"26864\"\n \"parent_mrid\" : \"36194\"\n \"player_id\" : \"174969\"\n \"script\" : \"--GA Bands by Cartoon Villain \\n--modded many times by rav3n_pl\\n\\nnormal=true --set false for Xploration puzzle !!!\\n\\n--[[\\n    Beware: Ugly code ahead. And I mean it!\\n    \\n    A _primative_ genetic algorithm on bands.\\n\\n    Run this in the early to mid game\\\, after you have\\n    a general structure but long before you do your tweaks\\n    to get the last few fractions of a point.\\n\\n    A brief overview:\\n\\n    1) [Optional] Create some bands that you think may help the fold.\\n       The bands that you create will not be modified.  Note\\\, that the\\n       bands that you create do not have to be anchored at both ends.\\n\\n    2) This script will fill in random bands to make a enuf bands so that\\n       the genetic algorithm can run smoothly.  These bands will be\\n       anchored and they may be deleted by the script.\\n\\n    3) The script generates a \\\"herd\\\" of random critters\\\, a critter is a\\n       subset of all of the bands both user and script generated.\\n\\n    4) Score how well each critter (band subset) does.\\n\\n    5) Keep the best critters and kill the rest.\\n\\n    6) \\\"Breed\\\" the critters you kept by mixing rougly half of the bands\\n       from the \\\"mom\\\" with half of the bands from the \\\"dad\\\" critter. Do\\n       this until you have filled the herd back up.\\n\\n    7) Some critters are mutated during breeding. A mutation is\\n       the replacement of one of the critter's bands with another\\n       randomly chosen band.\\n\\n    8) If the scores aren't going anywhere after a few generations\\n       start over with a new herd and a new set of script generated\\n       bands\\\, step 2.\\n\\n    9) Repeat from the scoring step (4) until the max generation is\\n       reached or we can't lock the script generated bands.\\n\\n    This is a greedy GA\\\, we keep score increases as soon as they occur.\\n    If it's half way thru scoring a generation then so be it. This is why\\n    we use relative improvements as a critter score.\\n--]]\\n\\nsegCnt=get_segment_count()\\np=print\\nCI=set_behavior_clash_importance\\n\\nfunction round(x)--cut all afer 3-rd place\\n    return x-x%0.001\\nend\\nfunction down(x)\\n    return x-x%1\\nend\\n\\nfunction Score()--return score\\\, exploration too\\n    local s=0\\n    if normal==true then\\n        s=get_score(true)\\n    else\\n        s=get_ranked_score(true)\\n    end\\n    return s\\nend \\n\\nfunction Wiggle(how\\\, iters\\\, minppi)\\n    if how==nil then how=\\\"wa\\\" end\\n    if iters==nil then iters=6 end\\n    if minppi==nil then minppi=0.1 end\\n    \\n    if iters>0 then\\n        iters=iters-1\\n        sp=Score()\\n        if how == \\\"s\\\" then do_shake(1)\\n            elseif how == \\\"wb\\\" then do_global_wiggle_backbone(2)\\n            elseif how == \\\"ws\\\" then do_global_wiggle_sidechains(2)\\n            elseif how == \\\"wa\\\" then do_global_wiggle_all(2) \\n        end\\n        ep = Score()\\n        ig=ep-sp\\n        if how~=\\\"s\\\" then\\n            if ig > minppi then return Wiggle(how\\\, iters\\\, minppi) end --tail call\\n        end\\n    end\\nend\\nfunction AllLoop() --turning entire structure to loops\\n    local ok=false\\n    for i=1\\\, segCnt do\\n        local s=get_ss(i)\\n        if s~=\\\"L\\\" then \\n            save_structure()\\n            ok=true\\n            break\\n        end\\n    end\\n    if ok then\\n        select_all()\\n        replace_ss(\\\"L\\\")\\n    end\\nend\\n\\n--[[\\nTlaloc`s math library\\n------------------------------------------------------------------------\\nThe original random script this was ported from has the following notices:\\nCopyright (c) 2007 Richard L. Mueller\\nHilltop Lab web site - http://www.rlmueller.net\\nVersion 1.0 - January 2\\\, 2007\\nYou have a royalty-free right to use\\\, modify\\\, reproduce\\\, and\\ndistribute this script file in any way you find useful\\\, provided that\\nyou agree that the copyright owner above has no warranty\\\, obligations\\\,\\nor liability for such use.\\n------------------------------------------------------------------------\\n]]--\\nlocal lngX = 1000\\nlocal lngC = 48313\\n\\nlocal function _random(m\\\,n)\\n    local A_Hi = 63551\\n    local A_Lo = 25354\\n    local M = 4294967296\\n    local H = 65536\\n    \\n    function _MWC()\\n        local S_Hi = math.floor(lngX / H)\\n        local S_Lo = lngX - (S_Hi * H)\\n        local C_Hi = math.floor(lngC / H)\\n        local F1 = A_Hi * S_Hi\\n        local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi\\n     \\n        lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)\\n        lngX = lngX - (math.floor(lngX / M) * M)\\n        lngC = math.floor((F2 / H) + F1)\\n\\n        return lngX\\n    end\\n    \\n    if n == nil and m ~= nil then\\n        n = m\\n        m = 1\\n    end\\n    if (m == nil) and (n == nil) then\\n        return _MWC() / M\\n    else\\n        if n < m then\\n            return nil\\n        end\\n        return math.floor((_MWC() / M) * (n - m + 1)) + m\\n    end\\nend\\n\\nlocal function _abs(value)\\n    if value < 0 then\\n        return -value\\n    else\\n        return value\\n    end\\nend\\n\\nlocal function _floor(value)\\n    return value - (value % 1)\\nend\\n\\nlocal function _randomseed(s)\\n    if s==nil then \\n        s=math.abs(Score())\\n        s=s%0.001\\n        s=1/s\\n        while s<10000 do s=s*1000 end\\n        s=s-s%1\\n    end\\n    lngX = s\\nend\\n\\nmath=\\n{\\n    abs = _abs\\\,\\n    floor = _floor\\\,\\n    random = _random\\\,\\n    randomseed = _randomseed\\\,\\n}\\nmath.randomseed()\\n--[[ End math library ]]--\\n\\nfunction CanBeUsed(sg1\\\,sg2) --checking end of bands\\n    local ok=true\\n    if \\\#DoNotUse>0 then --none of 2 can be in that area\\n        for i=1\\\, \\\#DoNotUse do\\n            local r=DoNotUse[i]\\n            for x=r[1]\\\,r[2] do\\n                if x==sg1 or x==sg2 then\\n                    ok=false\\n                    break\\n                end\\n            end\\n            if ok==false then break end\\n        end\\n    end\\n    if ok==false then \\n        return false --if false can`t be used\\n    else\\n        ok=false\\n        if \\\#AlwaysUse>0 then --at least one have to be there\\n            for i=1\\\, \\\#AlwaysUse do\\n                local r=AlwaysUse[i]\\n                for x=r[1]\\\,r[2] do\\n                    if x==sg1 or x==sg2 then\\n                        ok=true\\n                        break\\n                    end\\n                end\\n                if ok==true then break end\\n            end\\n        else\\n            ok=true\\n        end\\n        return ok --if true can be used\\n    end    \\nend\\n\\nbestScore=Score()\\nfunction SaveBest()\\n    local g=Score()-bestScore\\n    if g>0 then\\n        if g>0.1 then p(\\\"Gained another \\\"\\\,round(g)\\\,\\\" pts.\\\") end\\n        bestScore=Score()\\n        quicksave(3)\\n    end\\nend\\nfunction SaveRB()\\n    if normal==false then return end --not in exploration\\n    quicksave(4)\\n    restore_recent_best()\\n    SaveBest()\\n    quickload(4)\\nend\\n\\nfunction qStab()\\n    select_all()\\n    CI(0.1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    if fastQstab==false then \\n        CI(0.4)\\n        Wiggle(\\\"wa\\\"\\\,1)\\n        CI(1)\\n        Wiggle(\\\"s\\\"\\\,1)\\n    end\\n    CI(1)\\n    Wiggle()\\nend\\n\\nfunction FuzeEnd()\\n    CI(1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    Wiggle()\\n    SaveBest()\\nend\\nfunction Fuze1(ci1\\\,ci2)\\n    CI(ci1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\nend\\nfunction Fuze2(ci1\\\,ci2)\\n    CI(ci1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\nend\\nfunction reFuze(scr)\\n    local s=Score()\\n    if s<scr then \\n        quickload(4)\\n    else\\n        scr=s\\n        quicksave(4)\\n    end\\n    return scr\\nend\\nfunction Fuze()\\n    local scr=Score()\\n    quicksave(4)\\n    select_all()\\n    Fuze1(0.3\\\,0.6) FuzeEnd()\\n    scr=reFuze(scr)\\n    Fuze2(0.3\\\,1) SaveBest()\\n    scr=reFuze(scr)\\n    Fuze1(0.05\\\,1) SaveBest()\\n    scr=reFuze(scr)\\n    Fuze2(0.7\\\,0.5) FuzeEnd()\\n    scr=reFuze(scr)\\n    Fuze1(0.07\\\,1) SaveBest()\\n    reFuze(scr)\\nend\\n\\n-- Per critter parameters\\nCritter = {\\n    idCounter = 0\\\, -- Used to generate critter IDs\\n    minBands  = 3\\\, -- Min number of bands\\n    maxBands  = 5\\\, -- Max number of bands\\n    startScore=0\\\, --starting score of critter (rav3n)\\n}\\n\\n-- Parameters dealing with the herd\\nHerd = {\\n    keep           = 3\\\,  -- This many survive to next generation\\n    breed          = 3\\\,  -- Breed this many replacements\\n    generation     = 1\\\,  -- What generation is this\\n    maxGeneration  = 20\\\, -- Quit after this many generations\\n    improvementWas = 0\\\,  -- How good did the last generation do\\n    scoreBefore    = 0\\\,  -- Score at the start of a generation\\n    rebootLimit    = 2\\\,  -- Reboot after this many 0 improvement generations\\n    rebootCount    = 0\\\,  -- How close are we to the reboot limit\\n    mutateRate     = 4\\\,  -- On average mutate 1 out this many new borns\\n    rebootScore    = 0.1\\\, -- Only increment reboot count when below this\\n    startingScore  = Score()\\\, -- Score at the start of the script\\n}\\nHerd.size = Herd.keep + Herd.breed\\n\\n-- Parameters dealing with bands\\nBand = {\\n    userMade    = get_band_count()\\\, -- How many bands did user enter\\n    maxLength   = 5\\\, --max difference between position of segments and mand length\\n    minStrength = 0.1\\\,\\n    maxStrength = 1\\\,\\n    locked      = false\\\, -- Were we able to lock the script generated bands\\n}\\n\\n-- How many random bands to make\\nBand.scriptMade = (Herd.size * Critter.maxBands) - Band.userMade\\nif Band.scriptMade<0 then Band.scriptMade=1 end --if user made soooo many bands\\n\\n-- A random float between [0\\\, 1)\\nfunction RandomFloat()\\n    return math.random()\\nend\\n\\n -- A random int between [1\\\, high]\\nfunction RandomInt(high)\\n    return math.random(high)\\nend\\n\\n-- Generate a random band\\nfunction CreateBand()\\n    local start  = RandomInt(segCnt)\\n    local finish = RandomInt(segCnt)\\n    if  start~=finish and --not make band to same place\\n        math.abs(start-finish)>= minDist and --do not band if too close\\n        CanBeUsed(start\\\,finish) --at least one need to be in place\\n    then\\n        band_add_segment_segment(start\\\, finish)\\n        local range    = Band.maxStrength - Band.minStrength\\n        local strength = (RandomFloat() * range) + Band.minStrength\\n        local n = get_band_count()\\n        if n > 0 then band_set_strength(n\\\, strength) end\\n        \\n        local length = get_segment_distance(start\\\,finish)  -- +-2-maxLenght form curent segments distance\\n        local rn=0\\n        while true do\\n            rn=RandomFloat()*Band.maxLength*2-Band.maxLength\\n            if rn<=-3 or rn >=3 then break end\\n        end\\n        length=length+rn\\n        --3+ (RandomFloat() * (Band.maxLength-3)) --min len is 3\\n        --p(rn\\\, \\\" \\\"\\\,length) --debug\\n        if compressor then\\n            length = get_segment_distance(start\\\,finish)-compressFrac --compressing\\n        else\\n            if push then\\n                local dist = get_segment_distance(start\\\,finish)\\n                if dist >2 then length=dist*1.5 end\\n            end\\n            \\n            if hydroPull then\\n                if is_hydrophobic(start) and is_hydrophobic(finish)  then \\n                    length=3 --always pull hydrophobic pair\\n                end\\n            end\\n        end\\n        --if length >20 then length=20 end\\n        if length <0 then length=0 end\\n        if n > 0 then band_set_length(n\\\, length) end                \\n    else\\n        CreateBand()\\n    end\\nend\\n\\nfunction CreateBands()\\n    local i\\n    p(\\\"Creating bands...\\\")\\n    for i = 1\\\, Band.scriptMade do\\n        CreateBand()\\n    end\\nend\\n\\nfunction DeleteScriptMadeBands()\\n    if Band.userMade==0 then \\n        band_delete() --if no user bands del them all\\n    else \\n        local b\\n        for b = get_band_count()\\\, Band.userMade + 1\\\, -1 do\\n            band_delete(b)\\n        end\\n    end\\nend\\n\\nfunction DisableAllBands()\\n    band_disable()\\nend\\n\\nfunction EnableCritterBands(critter)\\n    local b\\n    for b = 1\\\, critter.bands do\\n        band_enable(critter.band[b])\\n    end\\nend\\n\\n-- Default critter constructor\\nfunction NewCritter()\\n    Critter.idCounter = Critter.idCounter + 1\\n    local critter = { bands = 0\\\, score = -999999\\\, age = 0\\\, mutated = false\\\, startScore = 0\\\, }\\n    critter.id = Herd.generation .. \\\"_\\\" .. Critter.idCounter\\n    critter.band = {}\\n    return critter\\nend\\n\\n-- Constructor for generating a completely random critter\\nfunction RandomCritter()\\n    local i\\n    local critter = NewCritter()\\n    critter.mutated = true\\n    critter.id = critter.id .. \\\"r\\\"\\n    critter.bands = RandomInt(Critter.maxBands - Critter.minBands)\\n                  + Critter.minBands\\n    local max = get_band_count()\\n    for i = 1\\\, critter.bands do\\n        critter.band[i] = RandomInt(max)\\n    end\\n\\n    return critter\\nend\\n\\n-- Lock in the script generated bands so that they will\\n-- appear when we do a restore_abs_best()\\n-- I would love to replace this with a slotted recent best\\nfunction LockBands()\\n    CI(1)\\n    if Band.scriptMade <= 0 then\\n        Band.locked = true\\n        return\\n    end\\n    reset_recent_best() --save bands\\n    Band.locked = true\\n    quicksave(3) --to be 200% sure\\n    p(\\\"Bands locked\\\")\\nend\\n\\n-- Generate a random heard. This includes all new critters\\\,\\n-- and a new set of script generated bands\\nfunction RandomHerd()\\n    local i\\n    DeleteScriptMadeBands()\\n    \\n    if Herd.generation>1 and randomOptions then --randomize push/pull\\n        local r=RandomInt(10)\\n        if r%2==0 then compressor=true p(\\\"Compressing.\\\") else compressor=false end\\n        if compressor==false then\\n            local r=RandomInt(10)\\n            if r%2==0 then push=true p(\\\"Pushing.\\\") else push=false end\\n            r=RandomInt(10)\\n            if r%2==0 then hydroPull=true p(\\\"Pulling hydros.\\\") else hydroPull=false end\\n        end\\n    end\\n    \\n    CreateBands()\\n    DisableAllBands()\\n    LockBands()\\n    for i = 1\\\, Herd.size do\\n        Herd[i] = RandomCritter()\\n        p(\\\"randomize: \\\"\\\, Herd[i].id)\\n    end\\n    \\nend\\n\\nfunction ScoreHerd()\\n    local i\\n    local first = 1 \\n    local hs=Score()\\n    for i = 1\\\, Herd.size do\\n        quicksave(5) --restore it if to much loss\\n        local label   = \\\"  unchanged score: \\\"\\n        local critter = Herd[i]\\n        \\n        if critter.startScore == Score() then\\n            first=first+1\\n        end\\n        \\n        if i >= first or critter.mutated then\\n            label = \\\"  score: \\\"\\n            local startingScore = Score()\\n            critter.startScore = startingScore\\n            \\n            DisableAllBands()\\n            EnableCritterBands(critter)\\n            select_all()\\n            local pullS=Score()\\n            CI(wiggleCI)\\n            do_global_wiggle_backbone(1)\\n            CI(1)\\n            DisableAllBands()\\n            SaveRB() --sometimes it wotks ;]\\n            if useQstab then\\n                if math.abs(Score()-pullS)>doQstab then\\n                    qStab()\\n                else \\n                    Wiggle() \\n                end\\n                \\n                if Score()>bestScore-doFuze and useFuze==true then\\n                    Fuze()\\n                end\\n            else\\n                Fuze() --run it when not using qStab\\n            end\\n            \\n            SaveBest() --if not use any fuze or so.\\n            \\n            critter.score = Score() - startingScore\\n            \\n            if critter.score<= 0.001 and critter.score>-0.1 then \\n                critter.score=-999 --no change\\\, we not need it\\n            end\\n            \\n            if loss==true then\\n                if critter.score<0-maxLoss then \\n                    quickload(5) --too negative score\\n                end \\n            else --next critter from best state\\n                quickload(3)\\n            end\\n        end\\n\\n        critter.age = critter.age + 1\\n        critter.mutated = false\\n        p(\\\"critter: \\\"\\\, critter.id\\\, label\\\, round(critter.score))\\n    end\\n    quickload(3)\\n    if mutate and Score()-hs>1 then--if more than 1pt change\\n        select_all()\\n        CI(mutateCI)\\n        do_mutate(1)\\n        CI(1)\\n        qStab()\\n    end\\nend\\n\\nfunction SwapCritter(a\\\, b)\\n    Herd[a]\\\,Herd[b]=Herd[b]\\\,Herd[a]--yes! in LUA you can do that!\\nend\\n\\n-- A quasi sort function. Only sort what is kept.\\n-- A small N means that I'm OK with this being a quadratic sort\\nfunction CullHerd()\\n    local weakest = 1 -- Survivor with the lowest score\\n    local i\\\, j\\n\\n    for i = 2\\\, Herd.size do\\n        if Herd[i].score > Herd[weakest].score then\\n            SwapCritter(i\\\, weakest)\\n            j = weakest\\n            while j > 1 and Herd[j].score > Herd[j-1].score do\\n                SwapCritter(j\\\, j-1)\\n                j = j - 1\\n            end\\n        end\\n        weakest = weakest + 1\\n        if weakest > Herd.keep then weakest = Herd.keep end\\n    end\\n\\n    for i = 1\\\, Herd.keep do\\n        p(\\\"kept: \\\"\\\, Herd[i].id\\\, \\\"  score: \\\"\\\, round(Herd[i].score))\\n    end\\nend\\n\\n-- Mix bands from the mom and dad critter\\\, rougly half from each\\nfunction BreedPair(mom\\\, dad)\\n    local kid = NewCritter()\\n    local k\\\, i\\\, b = 0\\\, 0\\\, 0\\n\\n    -- Choose bands from the mom\\n    b = RandomInt(mom.bands)\\n    for i = 1\\\, (mom.bands / 2) + 0.5 do\\n        k = k + 1\\n        kid.band[k] = mom.band[b]\\n\\n        b = b + 1\\n        if b > mom.bands then b = 1 end\\n    end\\n\\n    -- Choose bands from the dad\\n    b = RandomInt(dad.bands)\\n    for i = 1\\\, dad.bands / 2 do\\n        k = k + 1\\n        kid.band[k] = dad.band[b]\\n\\n        b = b + 1\\n        if b > dad.bands then b = 1 end\\n    end\\n\\n    kid.bands = k\\n    return kid\\nend\\n\\n-- Breed survivors with each other\\n-- 1st breeds w/ 2nd and 2nd w/ 3rd etc.\\n-- When that's done 1st breeds w/ 3rd and so on.\\nfunction BreedHerd()\\n    local mom\\\, dad\\\, kid = 0\\\, 0\\\, 0\\n    local step = 0 -- Dad is this far away from mom +1\\n    local keep = Herd.keep\\n\\n    for kid = keep + 1\\\, Herd.size do\\n        mom = mom + 1\\n        if mom > keep then\\n            mom = 1\\n            step = step + 1\\n        end\\n        dad = ((mom + step) % keep) + 1\\n        Herd[kid] = BreedPair(Herd[mom]\\\, Herd[dad])\\n        p(\\\"breeding:  mom: \\\"\\\, Herd[mom].id\\\,\\n                       \\\"  dad: \\\"\\\, Herd[dad].id\\\,\\n                       \\\"  kid: \\\"\\\, Herd[kid].id)\\n    end\\nend\\n\\n-- Mutate a random selection of the new born critters. A mutation\\n-- is the replacement of one of the critter's randomly chosen bands\\n-- with another band randomly choosen from the entire band set.\\nfunction MutateHerd()\\n    local i\\\, zap\\\, new\\\, mutate\\\, max\\n    max = get_band_count()\\n    for i = Herd.keep + 1\\\, Herd.size do\\n        mutate = RandomInt(Herd.mutateRate)\\n        if mutate == 1 then\\n            zap = RandomInt(Herd[i].bands)\\n            new = RandomInt(max)\\n            Herd[i].band[zap] = new\\n            Herd[i].mutated   = true\\n            Herd[i].id        = Herd[i].id .. \\\"m\\\"\\n            p(\\\"Mutating: \\\"\\\, Herd[i].id\\\, \\\"  zapped: \\\"\\\, zap)\\n        end\\n    end\\nend\\n\\nfunction ga()\\n    Herd.size = Herd.keep + Herd.breed\\n    Band.scriptMade = (Herd.size * Critter.maxBands) - Band.userMade\\n    if Band.scriptMade<0 then Band.scriptMade=1 end --if user made soooo many bands\\n    \\n    p(\\\"Starting GA Bands v2.1 ...\\\") \\n    if normal==false then p(\\\"Using exploration puzzle settings.\\\") end\\n    if allLoop then AllLoop() end\\n    quicksave(3)\\n    select_all()\\n    RandomHerd()\\n\\n    while Band.locked and Herd.generation <= Herd.maxGeneration do\\n        p(\\\"\\\")\\n        p(\\\"generation: \\\"\\\, Herd.generation\\\,\\\" of \\\"\\\,Herd.maxGeneration\\\, \\\" Start score: \\\"\\\,round(Score()))\\n\\n        if Herd.rebootCount >= Herd.rebootLimit then\\n            RandomHerd()\\n            Herd.rebootCount = 0\\n        end\\n        Herd.generation = Herd.generation + 1\\n\\n        Herd.scoreBefore = Score()\\n\\n        ScoreHerd()\\n        CullHerd()\\n        BreedHerd()\\n        MutateHerd()\\n\\n        Herd.improvementWas = Score() - Herd.scoreBefore\\n        p(\\\"score: \\\"\\\,             round(Score()))\\n        p(\\\"improvement: \\\"\\\,       round(Herd.improvementWas))\\n        p(\\\"total improvement: \\\"\\\, round(Score() - Herd.startingScore))\\n\\n        if Herd.improvementWas < Herd.rebootScore then\\n            Herd.rebootCount = Herd.rebootCount + 1\\n        else\\n            Herd.rebootCount = 0\\n        end\\n        p(\\\"reboot count: \\\"\\\, Herd.rebootCount\\\, \\\"  limit: \\\"\\\, Herd.rebootLimit)\\n        quickload(3) --every herd load best state\\n    end\\n\\n    DeleteScriptMadeBands()\\n    quickload(3)--load best state\\n    if allLoop then load_structure() end\\n    LockBands()\\nend\\n\\n-- V V V V V editable options below V V V V V\\n-- option to use normal or exploration puzze is ON TOP OF SCRIPT!\\n\\nDoNotUse={--just comment lines below or add more areas to avoid\\n--{segCnt\\\,segCnt}\\\, --ligand cant be used\\n--{120\\\,134}\\\,\\n--{1\\\,10}\\\,\\n}\\nAlwaysUse={ --areas should be always used\\n--{segCnt\\\,segCnt}\\\,--ligand need to be at one end\\n--{308\\\,311}\\\, --loopy\\n--{313\\\,317}\\\, --loopy\\n}\\n\\nHerd.keep = 3  -- This many survive to next generation\\nHerd.breed = 6  -- Breed this many replacements\\n--3+6=9 critters in herd\\n\\nCritter.minBands  = 4 -- Min number of bands\\nCritter.maxBands  = 7 -- Max number of bands    \\n    \\nBand.minStrength=0.3 --minimum band STR\\nBand.maxStrength=1.1 --maximum band STR\\nBand.maxLength = 7 --maximum distance of push/pull (min is 2)\\nminDist=down(segCnt/10)  --minimum dist (in segments) between banded segments\\n\\nmutate=false --true --do mutate(1) + qstab each generation\\nmutateCI=0.1 --clash importance during mutate\\n\\nuseQstab=true --quick stabilize to see that fuze have any chance \\n              --if false one (or both) of fuze/s are runned anyway\\ndoQstab=10 --run qstab only if loss is more than that. othwewise only wiggle\\nfastQstab=true --false --if true only 1 shake and 1 wiggle as qstab\\n\\nuseFuze=true --run Fuze when condition below met or not using qstab\\ndoFuze=-1 --how close to best score after stabilize to run PF\\n\\n--options below are valid only until reboot. it might change every reboot.\\ncompressor=false --true --making all bands shorter to compress protein OVERRIDES PUSH AND PULL!\\ncompressFrac=4 --shorten by that much. looks like 4 is good value\\npush=false --always push when possible (hydros may be excluded)\\nhydroPull=false --always pul hydrophobic pair\\nrandomOptions=false --true --randomizing push/pull/compressor options every reboot\\n\\nallLoop=false --run in all-loop mode (sometimes works better!)\\n\\nwiggleCI=0.9 --clash impotrance during push/pull\\nloss=true --false --true --do not reload best score between critters in herd if true\\nmaxLoss=30 --maximum loss by criter\\\, reloading last \\\"good\\\" herd position- not best total!\\n\\nHerd.maxGeneration  = 200 --how many generations. More=longer run\\nHerd.rebootLimit = 2 --how many gens w/o improvement to random new bands 1-random after 1st bad one\\n\\n--- end of options -------^^^\\n\\n--main call\\nga()\\n\\n\\n\\n\\n\\n\\n--end of script\"\n \"script_version\" : \"1\"\n \"share_scope\" : \"1685024045\"\n \"type\" : \"script\"\n \"uses\" : \"15\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1069706148" : "{\n \"desc\" : \"find middle of protein\\\, designated as frozen segment.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"FIND-MIDDLE - SG2011\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"0\"\n \"script\" : \"-- find-middle --\\nlocal mid = math.floor(structure.GetCount()/2)\\nprint('find-middle recipe\\\\nworking..\\\\n..Done.')\\nfreeze.Freeze(mid\\\,true\\\,true)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"94208\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_114005844" : "{\n \"desc\" : \"Freeze HELICES\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"FREEZE HELICES\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"0\"\n \"script\" : \"local j = structure.GetCount()\\nfor i=1\\\,j do\\n    if structure.GetSecondaryStructure(i) ~= 'H' then\\n      freeze.Freeze(i\\\,true\\\,false)\\n    end\\nend\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"94208\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1218555177" : "{\n \"desc\" : \"locate worst scoring segment.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"FIND - WORST -- SG2011\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"0\"\n \"script\" : \"--FIND-WORST--SG--\\nlocal k = structure.GetCount()\\nprint('FIND WORST - SG2011')\\nlocal min = { seg=1\\\,score=recentbest.GetSegmentEnergyScore(1) }\\nlocal s_0 = 0\\nfor i=2\\\,k do\\n  s_0 = recentbest.GetSegmentEnergyScore(i)\\n  if s_0<min.score then\\n    min.seg = i\\n    min.score = s_0\\n  end\\nend\\nselection.DeselectAll()\\nselection.Select(min.seg)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"94208\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1237962268" : "{\n \"desc\" : \"Fixed bonus filter issue when bonus is high\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"Tvdl enhanced DRW 2.8.1 -- SG\"\n \"parent\" : \"101708\"\n \"parent_mrid\" : \"202324\"\n \"player_id\" : \"0\"\n \"script\" : \"--[[\\n    Based on Rav3n_pl Deep Rebuild v3.x\\n    WARNING!\\n    1) Script uses a lot of save slots\\n    2) Best score are always in slot 3\\n\\nDescription:\\nThis is a long run rebuilder. Idea is to rebuild given/found area so many tyimes to found better position.\\nEach rebuild is scored in different ways and saved if better.\\nAfter rebuild finishes script is trying to stabilize each different saved position.\\nBecause some positions are best in more than 1 way sometimes it is only 1 positions to stabilize.\\nOn the best position a fuze is run if it looks promissing enough.\\n\\nChanged by: Timo van der Laan 17-12-2011 till 28-12-2012\\n]]--\\n\\n--[[\\nOverview:\\n\\nThis version of Rav3n_pl DRW has several new features.\\n\\nFirst of all it is made totally V2 and uses option dialogs.\\nIt has an optimised fuze and qStab\\\, and will run a lot faster as the original.\\nThe main optimalisation is that futile shakes and allready tried rebuilds are skipped.\\nAnother one is that unprommissing fuzes can be skipped.\\nFeatures (most have parameters):\\n1. Can be used in design puzzles\\\, has mutate options for that.\\n2. It will only recompute the next rebuild if there has been enough gain\\n3. It will not try to rebuild the exact same segments for a second time\\n4. It will not try a fuze if the loss is too great depending on the size of the rebuild\\n5. It will not try to rebuild frozen or locked parts\\n6. You can specify what parts of the protein to work on.\\n7. If you want it can keep disulfide bridges intact (thanks Brow42)\\n8. If the starting score is negative\\\, default is that no wiggles will be done to avoid exploding the protein.\\n9. If stopped\\\, it will reset CI\\\, best score and secondary structures.\\n10. You can skip a number of worst parts (handy after a crash)\\n11. It breaks off rebuild tries if no chance of success.\\n12. It works on puzzles even if the score is < -1000000 (but will be slower).\\n13. Fuze and qStab can be suppressed (default if score is negative from the start)\\n14. You can specify to disable bands when rebuilding and enable them afterwards.\\nNEW in version 2\\n15. You can choose which slots will be active\\n16. You can choose which segment scoreparts count for finding worst\\n17. It will recognize puzzle properties and set defaults for it\\n18. Instead of skipping cycles you can specify nr of worst to skip\\n19. On ED puzzles the other component is given proper weight for finding worst\\n20. Code has been cleaned up\\n21. And something special for Auntdeen :-)\\n2.1.0 Added code for disjunct searching\\\, fixed bridgesaving init.\\n2.1.1 Changed some max and min slider values and autodetects Layer Filter\\n2.2.0 Added ligand slot\\n2.3.0 GRRR Had to change other by Density\\n2.4.0 Dynamic list of active subscores\\\,\\n      Puts back the old selection when stopped\\\,\\n      Added rebuildnumber to the gainslot\\\,\\n      Added alternative local cleanup after rebuild\\\,\\n      Resets the original structure if mutated after rebuild for the next rb\\\,\\n      Sets default mutate settings if a design puzzle.\\n2.4.1 Added WiggleFactor\\\, remove reference as a slot\\n2.5.0 Added localshakes option Susume thanks\\n2.5.1 Wins during qstab wiggle will now be found.\\n2.6.0 Defaults and userinterface changed\\n2.7.0 Added option to disable slow filters on design puzzles\\n2.8.0 More general way to disable slow filters on design puzzles\\n2.8.1 Fixed filter problem when high bonus\\n]]--\\n\\n-- Handy shorts module\\nnormal= (current.GetExplorationMultiplier() == 0)\\nsegCnt=structure.GetCount()\\nsegCnt2=segCnt\\nwhile structure.GetSecondaryStructure(segCnt2)==\\\"M\\\" do segCnt2=segCnt2-1 end\\n\\n-- On request of gmn\\nCIfactor=1\\nmaxCI=true\\nfunction CI(CInr)\\n    if CInr > 0.99 then maxCI=true else maxCI=false end\\n    behavior.SetClashImportance(CInr*CIfactor)\\nend\\n\\nfunction CheckCI()\\n   local ask=dialog.CreateDialog(\\\"Clash importance is not 1\\\")\\n   ask.l1=dialog.AddLabel(\\\"Last change to change it\\\")\\n   ask.l2=dialog.AddLabel(\\\"CI settings will be multiplied by set CI\\\")\\n   ask.continue=dialog.AddButton(\\\"Continue\\\"\\\,1)\\n   dialog.Show(ask)\\nend\\n\\nif behavior.GetClashImportance() < 0.99 then CheckCI() end\\nCIfactor=behavior.GetClashImportance()\\n\\n-- Score functions\\nfunction Score(pose)\\n    if pose==nil then pose=current end\\n    local total= pose.GetEnergyScore()\\n    -- FIX for big negatives\\n\\n        if total < -999999 and total > -1000001 then total=SegScore(pose) end\\n\\n    if normal then\\n        return total\\n    else\\n        return total*pose.GetExplorationMultiplier()\\n    end\\nend\\n\\nfunction SegScore(pose)\\n    if pose==nil then pose=current end\\n    local total=8000\\n    for i=1\\\,segCnt2 do\\n        total=total+pose.GetSegmentEnergyScore(i)\\n    end\\n    return total\\nend\\n\\nfunction RBScore()\\n    return Score(recentbest)\\nend\\n\\nfunction round3(x)--cut all afer 3-rd place\\n    return x-x%0.001\\nend\\n\\n-- Module Filteractive\\n\\nFilterscore=Score()\\nbehavior.SetSlowFiltersDisabled(true)\\nFilterOffscore=Score()\\nbehavior.SetSlowFiltersDisabled(false)\\nmaxbonus=Filterscore-FilterOffscore\\n\\nfunction Filter()\\n   local ask=dialog.CreateDialog(\\\"Slow filters seem to be active\\\")\\n   ask.disable=dialog.AddCheckbox(\\\"Run with disabled slow filters\\\"\\\,Filteractive)\\n   ask.l1=dialog.AddLabel(\\\"Current bonus is: \\\"..maxbonus)\\n   ask.l2=dialog.AddLabel(\\\"If this is not the maximum bonus put in a number\\\")\\n   if maxbonus < 0 then maxbonus=0 end\\n   ask.maxbonus=dialog.AddTextbox(\\\"Set maxbonus:\\\"\\\,maxbonus)\\n   ask.l3=dialog.AddLabel(\\\"Scores will only be checked for real gains if\\\")\\n   ask.l4=dialog.AddLabel(\\\"Score with filter off+maxbonus is a potential gain\\\")\\n   ask.continue=dialog.AddButton(\\\"Continue\\\"\\\,1)\\n   dialog.Show(ask)\\n   maxbonus=ask.maxbonus.value\\nif maxbonus==\\\"\\\" then maxbonus=0 end\\n   Filteractive=ask.disable.value\\nend\\n\\nBetterRecentBest=false\\nfunction FilterOff()\\n    -- Filters off but restore a better recentbest with filter off\\n    behavior.SetSlowFiltersDisabled(true)\\n    if BetterRecentBest then\\n        save.Quicksave(99)\\n        save.Quickload(98)\\n        recentbest.Save()\\n        save.Quickload(99)\\n    end\\nend\\n\\nfunction FilterOn()\\n    -- Filter on but remember recent best if better than current\\n    BetterRecentBest= Score(recentbest) > Score()\\n    if BetterRecentBest then\\n        save.Quicksave(99)\\n        recentbest.Restore()\\n        save.Quicksave(98)\\n        save.Quickload(99)\\n    end\\n    behavior.SetSlowFiltersDisabled(false)\\nend\\n\\nFilteractive=(math.abs(maxbonus) > 0.1)\\nif Filteractive then\\n   --Filters active\\\, give people a choice\\n   --And ask what the maximum bonus is.\\n   Filter()\\nend\\n-- End of module Filteractive\\n\\nbestScore=Score()\\nif Filteractive then FilterOff() end\\nfunction SaveBest()\\n  if (not Filteractive) or\\n     (Score()+maxbonus>bestScore) then\\n     if Filteractive then FilterOn() end\\n     local g=Score()-bestScore\\n     if g>0 then\\n        if g>0.01 then print(round3(Score())..\\\" - Gained another \\\"..round3(g)..\\\" pts.\\\") end\\n        bestScore=Score()\\n        save.Quicksave(3)\\n     end\\n     if Filteractive then FilterOff() end\\n  end\\nend\\n\\n-- New WiggleFactor\\nWF=1\\n-- Wiggle function\\n-- Optimized due to Susumes ideas\\n-- Note the extra parameter to be used if only selected parts must be done\\nfunction Wiggle(how\\\, iters\\\, minppi\\\,onlyselected)\\n    --score conditioned recursive wiggle/shake\\n    --fixed a bug\\\, absolute difference is the threshold now\\n    if how==nil then how=\\\"wa\\\" end\\n    if iters==nil then iters=3 end\\n    if minppi==nil then minppi=0.1 end\\n    if onlyselected==nil then onlyselected=false end\\n    local wf=1\\n    if maxCI then wf=WF end\\n\\n    --if iters>0 then\\n        --iters=iters-1\\n        local sp=Score()\\n        if onlyselected then\\n            if how == \\\"s\\\" then\\n                -- Shake is not considered to do much in second or more rounds\\n                structure.ShakeSidechainsSelected(1)\\n                return\\n            elseif how == \\\"wb\\\" then structure.WiggleSelected(2*wf*iters\\\,true\\\,false)\\n            elseif how == \\\"ws\\\" then structure.WiggleSelected(2*wf*iters\\\,false\\\,true)\\n            elseif how == \\\"wa\\\" then structure.WiggleSelected(2*wf*iters\\\,true\\\,true)\\n            end\\n        else\\n            if how == \\\"s\\\" then\\n                -- Shake is not considered to do much in second or more rounds\\n                structure.ShakeSidechainsAll(1)\\n                return\\n            elseif how == \\\"wb\\\" then structure.WiggleAll(2*wf*iters\\\,true\\\,false)\\n            elseif how == \\\"ws\\\" then structure.WiggleAll(2*wf*iters\\\,false\\\,true)\\n            elseif how == \\\"wa\\\" then structure.WiggleAll(2*wf*iters\\\,true\\\,true)\\n            end\\n        end\\n        --if math.abs(Score()-sp) > minppi then return Wiggle(how\\\, iters\\\, minppi\\\,onlyselected) end\\n    --end\\nend\\n\\n-- end of handy shorts module\\n\\n-- Segment set and list module\\n-- Notice that most functions assume that the sets are well formed\\n-- (=ordered and no overlaps)\\n-- 02-05-2012 TvdL Free to use for non commercial purposes\\n\\nfunction SegmentListToSet(list)\\n    local result={}\\n    local f=0\\n    local l=-1\\n    table.sort(list)\\n    for i=1\\\,\\\#list do\\n        if list[i] ~= l+1 and list[i] ~= l then\\n            -- note: duplicates are removed\\n            if l>0 then result[\\\#result+1]={f\\\,l} end\\n            f=list[i]\\n        end\\n        l=list[i]\\n    end\\n    if l>0 then result[\\\#result+1]={f\\\,l} end\\n    --print(\\\"list to set\\\")\\n    --SegmentPrintSet(result)\\n    return result\\nend\\n\\nfunction SegmentSetToList(set)\\n    local result={}\\n    for i=1\\\,\\\#set do\\n        --print(set[i][1]\\\,set[i][2])\\n        for k=set[i][1]\\\,set[i][2] do\\n            result[\\\#result+1]=k\\n        end\\n    end\\n    return result\\nend\\n\\nfunction SegmentCleanSet(set)\\n-- Makes it well formed\\n    return SegmentListToSet(SegmentSetToList(set))\\nend\\n\\nfunction SegmentInvertSet(set\\\,maxseg)\\n-- Gives back all segments not in the set\\n-- maxseg is added for ligand\\n    local result={}\\n    if maxseg==nil then maxseg=structure.GetCount() end\\n    if \\\#set==0 then return {{1\\\,maxseg}} end\\n    if set[1][1] ~= 1 then result[1]={1\\\,set[1][1]-1} end\\n    for i=2\\\,\\\#set do\\n        result[\\\#result+1]={set[i-1][2]+1\\\,set[i][1]-1}\\n    end\\n    if set[\\\#set][2] ~= maxseg then result[\\\#result+1]={set[\\\#set][2]+1\\\,maxseg} end\\n    return result\\nend\\n\\nfunction SegmentInvertList(list)\\n    table.sort(list)\\n    local result={}\\n    for i=1\\\,\\\#list-1 do\\n       for j=list[i]+1\\\,list[i+1]-1 do result[\\\#result+1]=j end\\n    end\\n    for j=list[\\\#list]+1\\\,segCnt2 do result[\\\#result+1]=j end\\n    return result\\nend\\n\\nfunction SegmentInList(s\\\,list)\\n    table.sort(list)\\n    for i=1\\\,\\\#list do\\n        if list[i]==s then return true\\n        elseif list[i]>s then return false\\n        end\\n    end\\n    return false\\nend\\n\\nfunction SegmentInSet(set\\\,s)\\n    for i=1\\\,\\\#set do\\n        if s>=set[i][1] and s<=set[i][2] then return true\\n        elseif s<set[i][1] then return false\\n        end\\n    end\\n    return false\\nend\\n\\nfunction SegmentJoinList(list1\\\,list2)\\n    local result=list1\\n    if result == nil then return list2 end\\n    for i=1\\\,\\\#list2 do result[\\\#result+1]=list2[i] end\\n    table.sort(result)\\n    return result\\nend\\n\\nfunction SegmentJoinSet(set1\\\,set2)\\n    return SegmentListToSet(SegmentJoinList(SegmentSetToList(set1)\\\,SegmentSetToList(set2)))\\nend\\n\\nfunction SegmentCommList(list1\\\,list2)\\n    local result={}\\n    table.sort(list1)\\n    table.sort(list2)\\n    if \\\#list2==0 then return result end\\n    local j=1\\n    for i=1\\\,\\\#list1 do\\n        while list2[j]<list1[i] do\\n            j=j+1\\n            if j>\\\#list2 then return result end\\n        end\\n        if list1[i]==list2[j] then result[\\\#result+1]=list1[i] end\\n    end\\n    return result\\nend\\n\\nfunction SegmentCommSet(set1\\\,set2)\\n    return SegmentListToSet(SegmentCommList(SegmentSetToList(set1)\\\,SegmentSetToList(set2)))\\nend\\n\\nfunction SegmentSetMinus(set1\\\,set2)\\n    return SegmentCommSet(set1\\\,SegmentInvertSet(set2))\\nend\\n\\nfunction SegmentPrintSet(set)\\n    print(SegmentSetToString(set))\\nend\\n\\nfunction SegmentSetToString(set)\\n    local line = \\\"\\\"\\n    for i=1\\\,\\\#set do\\n        if i~=1 then line=line..\\\"\\\, \\\" end\\n        line=line..set[i][1]..\\\"-\\\"..set[i][2]\\n    end\\n    return line\\nend\\n\\nfunction SegmentSetInSet(set\\\,sub)\\n    if sub==nil then return true end\\n    -- Checks if sub is a proper subset of set\\n    for i=1\\\,\\\#sub do\\n        if not SegmentRangeInSet(set\\\,sub[i]) then return false end\\n    end\\n    return true\\nend\\n\\nfunction SegmentRangeInSet(set\\\,range)\\n    if range==nil or \\\#range==0 then return true end\\n    local b=range[1]\\n    local e=range[2]\\n    for i=1\\\,\\\#set do\\n        if b>=set[i][1] and b<=set[i][2] then\\n            return (e<=set[i][2])\\n        elseif e<=set[i][1] then return false end\\n    end\\n    return false\\nend\\n\\nfunction SegmentSetToBool(set)\\n    local result={}\\n    for i=1\\\,structure.GetCount() do\\n        result[i]=SegmentInSet(set\\\,i)\\n    end\\n    return result\\nend\\n--- End of Segment Set module\\n\\n-- Module Find Segment Types\\nfunction FindMutablesList()\\n    local result={}\\n    for i=1\\\,segCnt2 do if structure.IsMutable(i) then result[\\\#result+1]=i end end\\n    return result\\nend\\nfunction FindMutables()\\n    return SegmentListToSet(FindMutablesList())\\nend\\n\\nfunction FindFrozenList()\\n    local result={}\\n    for i=1\\\,segCnt2 do if freeze.IsFrozen(i) then result[\\\#result+1]=i end end\\n    return result\\nend\\nfunction FindFrozen()\\n    return SegmentListToSet(FindFrozenList())\\nend\\n\\nfunction FindLockedList()\\n    local result={}\\n    for i=1\\\,segCnt2 do if structure.IsLocked(i) then result[\\\#result+1]=i end end\\n    return result\\nend\\nfunction FindLocked()\\n    return SegmentListToSet(FindLockedList())\\nend\\n\\nfunction FindSelectedList()\\n    local result={}\\n    for i=1\\\,segCnt do if selection.IsSelected(i) then result[\\\#result+1]=i end end\\n    return result\\nend\\nfunction FindSelected()\\n    return SegmentListToSet(FindSelectedList())\\nend\\n\\nfunction FindAAtypeList(aa)\\n    local result={}\\n    for i=1\\\,segCnt2 do\\n        if structure.GetSecondaryStructure(i)== aa then result[\\\#result+1]=i end\\n    end\\n    return result\\nend\\nfunction FindAAtype(aa)\\n    return SegmentListToSet(FindAAtypeList(aa))\\nend\\n\\nfunction FindAminotype(at) --NOTE: only this one gives a list not a set\\n    local result={}\\n    for i=1\\\,segCnt2 do\\n        if structure.GetAminoAcid(i) == at then result[\\\#result+1]=i end\\n    end\\n    return result\\nend\\n-- end Module Find Segment Types\\n\\n-- Module to compute subscores\\n-- TvdL\\\, 14-12-2012\\nfunction GetSubscore(types\\\,seg1\\\,seg2\\\,pose)\\n    local result=0\\n    if type(types) == \\\"table\\\" then\\n        for i=1\\\,\\\#types do result=result+GetSubscore(types[i]\\\,seg1\\\,seg2\\\,pose) end\\n    else\\n        if types==nil and seg1==nil and seg2==nil then return Score(pose) end\\n        if seg1==nil then seg1=1 end\\n        if seg2==nil then seg2=segCnt end --includes ligands!\\n        if seg1>seg2 then seg1\\\,seg2=seg2\\\,seg1 end\\n        if pose==nil then pose=current end\\n        if types==nil then\\n            for i=seg1\\\,seg2 do result=result+pose.GetSegmentEnergyScore(i) end\\n        else\\n            for i=seg1\\\,seg2 do result=result+pose.GetSegmentEnergySubscore(i\\\,types) end\\n        end\\n    end\\n    if normal then return result else return result*pose.GetExplorationMultiplier() end\\nend\\n\\nfunction FindActiveSubscores(show)\\n    local result={}\\n    local Subs=puzzle.GetPuzzleSubscoreNames()\\n    local Showlist =\\\"Computing Active Subscores\\\"\\n    if show then print(Showlist) end\\n    for i=1\\\,\\\#Subs do\\n        local total=0\\n        for j=1\\\,segCnt do\\n            if Subs[i] == 'disulfides' and nrofbridges>0 then total=11 end\\n            total=total+math.abs(current.GetSegmentEnergySubscore(j\\\,Subs[i]))\\n            if total>10 then\\n                result[\\\#result+1]=Subs[i]\\n                if show then print(\\\"Active subscore: \\\"..Subs[i]) end\\n                break\\n            end\\n        end\\n    end\\n    return result\\nend\\n-- End module to compute subscores\\n\\n-- Position stack module 1.0\\n-- uses slot 50 and higher\\nStackmin=50\\nStackMarks={}\\nStackPos=50\\nfunction PushPosition()\\n    if StackPos==100 then\\n        print(\\\"Position stack overflow\\\, exiting\\\")\\n        exit()\\n    end\\n    save.Quicksave(StackPos)\\n    StackPos=StackPos+1\\nend\\n\\nfunction PopPosition()\\n    if StackPos==50 then\\n        print(\\\"Position stack underflow\\\, exiting\\\")\\n        exit()\\n    end\\n    StackPos=StackPos-1\\n    save.Quickload(StackPos)\\nend\\nfunction PushMarkPosition()\\n    StackMarks[\\\#StackMarks+1]=StackPos\\n    PushPosition()\\nend\\nfunction PopMarkPosition()\\n    if \\\#StackMarks == 0 then\\n        print(\\\"No marked position found\\\, just popping\\\")\\n    else\\n        StackPos=StackMarks[\\\#StackMarks]+1\\n        StackMarks[\\\#StackMarks]= nil\\n    end\\n    PopPosition()\\nend\\nfunction GetTopPosition()\\n    if StackPos==50 then\\n        print(\\\"No top position on the stack\\\, exiting\\\")\\n        exit()\\n    end\\n    save.Quickload(StackPos-1)\\nend\\nfunction ClrTopPosition()\\n    if StackPos > 50 then StackPos=StackPos-1 end\\nend\\n-- Start of module for bridgechecking\\nCyslist={}\\nsavebridges=false --default no bridgechecking\\nnrofbridges=0\\n\\nfunction setCyslist()\\n    Cyslist=FindAminotype(\\\"c\\\")\\n    nrofbridges=CountBridges()\\nend\\n\\nfunction IsBridge(i)\\n    if structure.IsLocked(i) then return false end\\n    return ''..current.GetSegmentEnergySubscore(i\\\,'disulfides') ~= '-0'\\nend\\n\\nfunction CountBridges()\\n    local count = 0\\n    for i = 1\\\,\\\#Cyslist do\\n        if IsBridge(Cyslist[i]) then count = count + 1 end\\n    end\\n    return count\\nend\\n\\nfunction BridgesBroken()\\n    return savebridges == true and CountBridges() < nrofbridges\\nend\\n\\nfunction Bridgesave()\\n    if savebridges then PushPosition() end\\nend\\n\\nfunction Bridgerestore()\\n    if savebridges then\\n        if BridgesBroken() then PopPosition() else ClrTopPosition() end\\n    end\\nend\\n\\n-- End module bridgechecking\\n\\n-- Module find puzzle properties\\n-- Tvdl 14-12-2012\\nHASMUTABLE=false\\nHASDENSITY=false\\nHASLIGAND= (segCnt2<segCnt)\\nDENSITYWEIGHT=0\\nPROBABLESYM=false\\nFREEDESIGN=false\\nISAUNTDEEN=false\\n\\nfunction SetPuzzleProperties()\\n    print(\\\"Computing puzzle properties\\\")\\n    -- Find out if the puzzle has mutables\\n    local MutList=FindMutablesList()\\n    HASMUTABLE= (\\\#MutList>0)\\n    if HASMUTABLE then print(\\\"Mutables found\\\") end\\n    FREEDESIGN= (segCnt2/2 < \\\#MutList)\\n    if FREEDESIGN then print(\\\"Design puzzle\\\") end\\n\\n    -- Find out if the puzzle has possible bridges\\n    setCyslist()\\n    if \\\#Cyslist > 1 then\\n        print(\\\"Puzzle has more than 1 cystine\\\")\\n        if nrofbridges > 0 then\\n            print(\\\"Puzzle has bridges\\\")\\n            savebridges=true\\n        end\\n    end\\n\\n    -- Find out is the puzzle has Density scores and their weight if any\\n    local Densitytot=GetSubscore(\\\"density\\\")\\n    local segtot=GetSubscore(nil\\\,1\\\,segCnt)\\n    HASDENSITY= math.abs(Densitytot) > 0.0001\\n    if normal and HASDENSITY then\\n        print(\\\"Puzzle has Density scores\\\")\\n        DENSITYWEIGHT=(Score()-segtot-8000)/Densitytot\\n        print(\\\"The Density component has an extra weight of \\\"..round3(DENSITYWEIGHT))\\n    end\\n\\n    -- Check if the puzzle is a probable symmetry one\\n    if normal and not HASDENSITY then\\n        PROBABLESYM=math.abs(Score()-segtot-8000) > 2\\n        if PROBABLESYM then print(\\\"Puzzle is a symmetry puzzle or has bonuses\\\") end\\n    end\\n\\n    -- Check to see if the player is auntdeen\\n    if user.GetPlayerName() == \\\"auntdeen\\\" then\\n        print(\\\"Hello auntdeen\\\")\\n        ISAUNTDEEN=true\\n    end\\nend\\n\\nSetPuzzleProperties()\\n-- End of module find puzzle properties\\n\\n-- Standard Fuze module\\n-- Picks up all gains by using recentbest\\n\\nfunction GetRB(prefun\\\,postfun)\\n    if RBScore()> Score() then\\n        if prefun ~= nil then prefun() end\\n        recentbest.Restore()\\n        if postfun ~= nil then postfun() end\\n    end\\nend\\n\\nfunction FuzeEnd(prefun\\\,postfun)\\n    if prefun ~= nil then prefun() end\\n    CI(1)\\n-- Wiggle(\\\"wa\\\"\\\,1)\\n-- Wiggle(\\\"s\\\"\\\,1)\\n    Wiggle()\\n    GetRB(prefun\\\,postfun)\\n    if postfun ~= nil then postfun() end\\n    SaveBest()\\nend\\n\\nfunction Fuze1(ci1\\\,ci2\\\,prefun\\\,postfun\\\,globshake)\\n    if prefun ~=nil then prefun() end\\n    if globshake==nil then globshake=true end\\n    CI(ci1)\\n    Wiggle(\\\"s\\\"\\\,1\\\,nil\\\,globshake)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    if postfun ~= nil then postfun() end\\nend\\n\\nfunction Fuze2(ci1\\\,ci2\\\,prefun\\\,postfun)\\n    if prefun ~= nil then prefun() end\\n    CI(ci1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    if postfun ~= nil then postfun() end\\nend\\n\\nfunction reFuze(scr\\\,slot)\\n    local s=Score()\\n    if s<scr then\\n        save.Quickload(slot)\\n    else\\n        scr=s\\n        save.Quicksave(slot)\\n    end\\n    return scr\\nend\\n\\nfunction Fuze(slot\\\,prefun\\\,postfun\\\,globshake)\\n    local scr=Score()\\n    if slot == nil then slot=4 save.Quicksave(slot) end\\n\\n    recentbest.Save()\\n    Fuze1(0.3\\\,0.6\\\,prefun\\\,postfun\\\,globshake) FuzeEnd(prefun\\\,postfun)\\n    scr=reFuze(scr\\\,slot)\\n    Fuze2(0.3\\\,1\\\,prefun\\\,postfun)\\n    GetRB(prefun\\\,postfun)\\n    SaveBest()\\n    scr=reFuze(scr\\\,slot)\\n    Fuze1(0.05\\\,1\\\,prefun\\\,postfun\\\,globshake)\\n    GetRB(prefun\\\,postfun)\\n    SaveBest()\\n    scr=reFuze(scr\\\,slot)\\n    Fuze2(0.7\\\,0.5\\\,prefun\\\,postfun) FuzeEnd()\\n    scr=reFuze(scr\\\,slot)\\n    Fuze1(0.07\\\,1\\\,prefun\\\,postfun\\\,globshake)\\n    GetRB(prefun\\\,postfun)\\n    SaveBest()\\n    reFuze(scr\\\,slot)\\n    GetRB(prefun\\\,postfun)\\n    SaveBest()\\nend\\n-- end standard Fuze module\\n\\n-- Module setsegmentset\\n-- Tvdl\\\, 11-05-2012 Free to use for noncommercial purposes\\nfunction SetSelection(set)\\n    selection.DeselectAll()\\n    if set ~= nil then for i=1\\\,\\\#set do\\n        selection.SelectRange(set[i][1]\\\,set[i][2])\\n    end end\\nend\\n\\nfunction SelectAround(ss\\\,se\\\,radius\\\,nodeselect)\\n    if nodeselect~=true then selection.DeselectAll() end\\n    for i=1\\\, segCnt2 do\\n        for x=ss\\\,se do\\n            if structure.GetDistance(x\\\,i)<radius then selection.Select(i) break end\\n        end\\n    end\\nend\\n\\nfunction SetAAtype(set\\\,aa)\\n    local saveselected=FindSelected()\\n    SetSelection(set)\\n    structure.SetSecondaryStructureSelected(aa)\\n    SetSelection(saveselected)\\nend\\n\\n-- Module AllLoop\\nSAVEDstructs=false\\nfunction AllLoop() --turning entire structure to loops\\n    local anychange=false\\n    for i=1\\\,segCnt2 do\\n        if structure.GetSecondaryStructure(i)~=\\\"L\\\" then\\n            anychange=true\\n            break\\n        end\\n    end\\n    if anychange then\\n        save.SaveSecondaryStructure()\\n        SAVEDstructs=true\\n        selection.SelectAll()\\n        structure.SetSecondaryStructureSelected(\\\"L\\\")\\n    end\\nend\\n\\nfunction qStab()\\n    -- Do not accept qstab losses\\n    local curscore=Score()\\n    PushPosition()\\n    CI(0.1)\\n    Wiggle(\\\"s\\\"\\\,1\\\,nil\\\,true) --shake only selected part\\n    if InQstab then\\n        CI(1)\\n        doMutate()\\n    end\\n    if fastQstab==false then\\n        CI(0.4)\\n        Wiggle(\\\"wa\\\"\\\,1)\\n        CI(1)\\n        Wiggle(\\\"s\\\"\\\,1\\\,nil\\\,localshakes)\\n    end\\n    CI(1)\\n    recentbest.Save()\\n    Wiggle()\\n    recentbest.Restore()\\n    if Score() < curscore then PopPosition() else ClrTopPosition() end\\nend\\n\\nfunction Cleanup(err)\\n    print(\\\"Restoring CI\\\, initial selection\\\, best result and structures\\\")\\n    CI(1)\\n    save.Quickload(3)\\n\\n    if Filteractive then FilterOn() end\\n    if SAVEDstructs==true then save.LoadSecondaryStructure() end\\n    selection.DeselectAll()\\n    if SAFEselection ~= nil then SetSelection(SAFEselection) end\\n    print(err)\\nend\\n\\n-- Module AskSelections\\n-- 02-05-2012 Timo van der Laan\\\, Free to use for non commercial purposes\\nfunction AskForSelections(title\\\,mode)\\n    local result={{1\\\,structure.GetCount()}} -- All segments\\n    if mode == nil then mode={} end\\n    if mode.askloops==nil then mode.askloops=true end\\n    if mode.asksheets==nil then mode.asksheets=true end\\n    if mode.askhelixes==nil then mode.askhelixes=true end\\n    if mode.askligands==nil then mode.askligands=false end\\n    if mode.askselected==nil then mode.askselected=true end\\n    if mode.asknonselected==nil then mode.asknonselected=true end\\n    if mode.askmutateonly==nil then mode.askmutateonly=true end\\n    if mode.askignorelocks==nil then mode.askignorelocks=true end\\n    if mode.askignorefrozen==nil then mode.askignorefrozen=true end\\n    if mode.askranges==nil then mode.askranges=true end\\n    if mode.defloops==nil then mode.defloops=true end\\n    if mode.defsheets==nil then mode.defsheets=true end\\n    if mode.defhelixes==nil then mode.defhelixes=true end\\n    if mode.defligands==nil then mode.defligands=false end\\n    if mode.defselected==nil then mode.defselected=false end\\n    if mode.defnonselected==nil then mode.defnonselected=false end\\n    if mode.defmutateonly==nil then mode.defmutateonly=false end\\n    if mode.defignorelocks==nil then mode.defignorelocks=false end\\n    if mode.defignorefrozen==nil then mode.defignorefrozen=false end\\n    local Errfound=false\\n  repeat\\n    local ask = dialog.CreateDialog(title)\\n    if Errfound then\\n        ask.E1=dialog.AddLabel(\\\"Try again\\\, ERRORS found\\\, check output box\\\")\\n        result={{1\\\,structure.GetCount()}} --reset start\\n        Errfound=false\\n    end\\n    if mode.askloops then\\n        ask.loops = dialog.AddCheckbox(\\\"Work on loops\\\"\\\,mode.defloops)\\n    elseif not mode.defloops then\\n        ask.noloops= dialog.AddLabel(\\\"Loops will be auto excluded\\\")\\n    end\\n    if mode.askhelixes then\\n        ask.helixes = dialog.AddCheckbox(\\\"Work on helixes\\\"\\\,mode.defhelixes)\\n    elseif not mode.defhelixes then\\n        ask.nohelixes= dialog.AddLabel(\\\"Helixes will be auto excluded\\\")\\n    end\\n    if mode.asksheets then\\n        ask.sheets = dialog.AddCheckbox(\\\"Work on sheets\\\"\\\,mode.defsheets)\\n    elseif not mode.defsheets then\\n        ask.nosheets= dialog.AddLabel(\\\"Sheets will be auto excluded\\\")\\n    end\\n    if mode.askligands then\\n        ask.ligands = dialog.AddCheckbox(\\\"Work on ligands\\\"\\\,mode.defligands)\\n    elseif not mode.defligands then\\n        ask.noligands= dialog.AddLabel(\\\"Ligands will be auto excluded\\\")\\n    end\\n    if mode.askselected then ask.selected = dialog.AddCheckbox(\\\"Work only on selected\\\"\\\,mode.defselected) end\\n    if mode.asknonselected then ask.nonselected = dialog.AddCheckbox(\\\"Work only on nonselected\\\"\\\,mode.defnonselected) end\\n    if mode.askmutateonly then ask.mutateonly = dialog.AddCheckbox(\\\"Work only on mutateonly\\\"\\\,mode.defmutateonly) end\\n    if mode.askignorelocks then\\n        ask.ignorelocks =dialog.AddCheckbox(\\\"Dont work on locked ones\\\"\\\,true)\\n    elseif mode.defignorelocks then\\n        ask.nolocks=dialog.AddLabel(\\\"Locked ones will be auto excluded\\\")\\n    end\\n    if mode.askignorefrozen then\\n        ask.ignorefrozen = dialog.AddCheckbox(\\\"Dont work on frozen\\\"\\\,true)\\n    elseif mode.defignorefrozen then\\n        ask.nofrozen=dialog.AddLabel(\\\"Frozen ones will be auto excluded\\\")\\n    end\\n    if mode.askranges then\\n        ask.R1=dialog.AddLabel(\\\"Or put in segmentranges. Above selections also count\\\")\\n        ask.ranges=dialog.AddTextbox(\\\"Ranges\\\"\\\,\\\"\\\")\\n    end\\n    ask.OK = dialog.AddButton(\\\"OK\\\"\\\,1) ask.Cancel = dialog.AddButton(\\\"Cancel\\\"\\\,0)\\n    if dialog.Show(ask) > 0 then\\n        -- We start with all the segments including ligands\\n        if mode.askloops then mode.defloops=ask.loops.value end\\n        if not mode.defloops then\\n            result=SegmentSetMinus(result\\\,FindAAtype(\\\"L\\\"))\\n        end\\n        if mode.asksheets then mode.defsheets=ask.sheets.value end\\n        if not mode.defsheets then\\n            result=SegmentSetMinus(result\\\,FindAAtype(\\\"E\\\"))\\n        end\\n        if mode.askhelixes then mode.defhelixes=ask.helixes.value end\\n        if not mode.defhelixes then\\n            result=SegmentSetMinus(result\\\,FindAAtype(\\\"H\\\"))\\n        end\\n        if mode.askligands then mode.defligands=ask.ligands.value end\\n        if not mode.defligands then\\n            result=SegmentSetMinus(result\\\,FindAAtype(\\\"M\\\"))\\n        end\\n        if mode.askignorelocks then mode.defignorelocks=ask.ignorelocks.value end\\n        if mode.defignorelocks then\\n            result=SegmentSetMinus(result\\\,FindLocked())\\n        end\\n        if mode.askignorefrozen then mode.defignorefrozen=ask.ignorefrozen.value end\\n        if mode.defignorefrozen then\\n            result=SegmentSetMinus(result\\\,FindFrozen())\\n        end\\n        if mode.askselected then mode.defselected=ask.selected.value end\\n        if mode.defselected then\\n            result=SegmentCommSet(result\\\,FindSelected())\\n        end\\n        if mode.asknonselected then mode.defnonselected=ask.nonselected.value end\\n        if mode.defnonselected then\\n            result=SegmentCommSet(result\\\,SegmentInvertSet(FindSelected()))\\n        end\\n        if mode.askranges and ask.ranges.value ~= \\\"\\\" then\\n            local rangetext=ask.ranges.value\\n            local function Checknums(nums)\\n                -- Now checking\\n                if \\\#nums%2 ~= 0 then\\n                    print(\\\"Not an even number of segments found\\\")\\n                    return false\\n                end\\n                for i=1\\\,\\\#nums do\\n                    if nums[i]==0 or nums[i]>structure.GetCount() then\\n                        print(\\\"Number \\\"..nums[i]..\\\" is not a segment\\\")\\n                        return false\\n                    end\\n                end\\n                return true\\n            end\\n\\n            local function ReadSegmentSet(data)\\n                local nums = {}\\n                local NoNegatives='%d+' -- - is not part of a number\\n                local result={}\\n                for v in string.gfind(data\\\,NoNegatives) do\\n                    table.insert(nums\\\, tonumber(v))\\n                end\\n                if Checknums(nums) then\\n                    for i=1\\\,\\\#nums/2 do\\n                        result[i]={nums[2*i-1]\\\,nums[2*i]}\\n                    end\\n                    result=SegmentCleanSet(result)\\n                else Errfound=true result={} end\\n                return result\\n            end\\n            local rangelist=ReadSegmentSet(rangetext)\\n            if not Errfound then\\n                result=SegmentCommSet(result\\\,rangelist)\\n            end\\n        end\\n    end\\n  until not Errfound\\n    return result\\nend\\n-- end of module AskSelections\\n\\nfunction Sort(tab\\\,items) --BACWARD bubble sorting - lowest on top\\\, only needed items\\n    for x=1\\\,items do --items do\\n        for y=x+1\\\,\\\#tab do\\n            if tab[x][1]>tab[y][1] then\\n                tab[x]\\\,tab[y]=tab[y]\\\,tab[x]\\n            end\\n        end\\n    end\\n    return tab\\nend\\n\\nfunction AddDone(first\\\,last)\\n    if donotrevisit then\\n        Donepart[first+(last-first)*segCnt2]=true\\n        Blocked[\\\#Blocked+1]=first+(last-first)*segCnt2\\n    end\\n    if disjunct then\\n        for i=first\\\,last do Disj[i]=true end\\n    end\\nend\\n\\nfunction CheckDone(first\\\,last)\\n    if not donotrevisit then return false end\\n    local result=Donepart[first+(last-first)*segCnt2]\\n    if disjunct then\\n        for i=first\\\,last do if Disj[i] then result=true end end\\n    end\\n    return result\\nend\\n\\nfunction ChkDisjunctList(n)\\n    if not disjunct then return end\\n    local maxlen=0\\n    for i=1\\\,segCnt2 do\\n        if Disj[i] then maxlen=0 else maxlen=maxlen+1 end\\n        if maxlen == n then return end\\n    end\\n    -- No part is big enough so clear Disjunctlist\\n    print(\\\"Clearing disjunct list\\\")\\n    for i=1\\\,segCnt2 do\\n        Disj[i]=false\\n    end\\nend\\n\\nfunction ClearDoneList()\\n    --clear donelist\\n    for i=1\\\,\\\#Blocked do Donepart[Blocked[i]]=false end\\n    if disjunct then\\n        --clear disjunctlist also\\n        for i=1\\\,segCnt2 do Disj[i]=false end\\n    end\\n    Blocked={}\\n    curclrscore=Score()\\nend\\n\\nfunction ChkDoneList()\\n    if not donotrevisit and not disjunt then return end\\n    if Score() > curclrscore+clrdonelistgain then\\n        if donotrevisit then ClearDoneList() end\\n    end\\nend\\n--end of administration part\\n\\nfunction FindWorst(firsttime)\\n    print(\\\"Searching worst scoring parts of len \\\"..len)\\n    ChkDisjunctList(len)\\n    wrst={}\\n    GetSegmentScores()\\n    local skiplist=\\\"\\\"\\n    local nrskip=0\\n    for i=1\\\,segCnt2-len+1 do\\n        if not CheckDone(i\\\,i+len-1) and MustWorkon(i\\\,i+len-1)\\n        then\\n            local s=getPartscore(i\\\,i+len-1)\\n            wrst[\\\#wrst+1]={s\\\,i}\\n        else\\n            if CheckDone(i\\\,i+len-1)\\n            then\\n                if nrskip==0 then print(\\\"Skipping\\\") end\\n                nrskip=nrskip+1\\n                skiplist=skiplist..i..\\\"-\\\"..(i+len-1)..\\\" \\\"\\n                if nrskip%7==0 then\\n                    print(skiplist)\\n                    skiplist=\\\"\\\"\\n                end\\n            end\\n        end\\n    end\\n    if nrskip%7 ~= 0 then print(skiplist) end\\n    if nrskip > 0 then print(\\\"Number of skips: \\\"..nrskip) end\\n    wrst=Sort(wrst\\\,reBuild)\\n    areas={}\\n    local rb=reBuild\\n    if rb>\\\#wrst then rb=\\\#wrst end\\n    for i=1\\\,rb do\\n        local w=wrst[i]\\n        local ss=w[2]\\n        areas[\\\#areas+1]={ss\\\,ss+len-1}\\n    end\\n    if firsttime and \\\#wrst == 0 then\\n        print(\\\"No possibilities left so clearing Done list\\\")\\n        ClearDoneList()\\n        FindWorst(false)\\n    end\\nend\\n\\n-- Rebuild section\\nfunction localRebuild(maxiters)\\n    if maxiters==nil then maxiters=3 end\\n    local s=Score()\\n    local i=0\\n    if bandflip then band.DisableAll() end\\n    Bridgesave()\\n    repeat\\n        i=i+1\\n        if i>maxiters then break end\\n        structure.RebuildSelected(i)\\n    until Score()~=s and BridgesBroken() == false\\n    if bandflip then band.EnableAll() end\\n    Bridgerestore()\\n    if Score()~=s then return true else return false end\\nend\\n\\nfunction ReBuild(ss\\\,se\\\,tries)\\n    ClearScores() --reset score tables\\n    if ss>se then ss\\\,se=se\\\,ss end --switch if needed\\n    local Foundone=false\\n    for try=1\\\,tries do -- perform loop for number of tries\\n        selection.DeselectAll()\\n        CI(rebuildCI)\\n        selection.SelectRange(ss\\\,se)\\n        local extra_rebuilds = 1\\n        if savebridges then extra_rebuilds=3 end --extra if bridges keep breaking\\n        local done\\n        repeat\\n            done=localRebuild(nil)\\n            extra_rebuilds = extra_rebuilds -1\\n        until done or extra_rebuilds == 0\\n        SaveBest()\\n        if done==true then\\n            Foundone=true\\n            Bridgesave()\\n            if doSpecial==true then\\n                SelectAround(ss\\\,se\\\,9)\\n                CI(1)\\n                Wiggle(\\\"s\\\"\\\,1\\\,nil\\\,true)\\n                Wiggle(\\\"ws\\\"\\\,2\\\,nil\\\,true)\\n                selection.DeselectAll()\\n                selection.SelectRange(ss\\\,se)\\n                Wiggle(\\\"wb\\\"\\\,4\\\,nil\\\,true)\\n                SelectAround(ss\\\,se\\\,9)\\n            elseif doShake==true then\\n                CI(shakeCI)\\n                Wiggle(\\\"s\\\"\\\,1\\\,nil\\\,true)\\n            end\\n            Bridgerestore()\\n            if AfterRB then\\n                PushPosition() --save the current position for next round\\n                doMutate()\\n            end\\n            SaveScores(ss\\\,se\\\,try)\\n            if AfterRB then PopPosition() end\\n        end\\n        if (try > 3 or savebridges) and Foundone==false then\\n            print(\\\"No valid rebuild found on this section\\\")\\n            print(\\\"After 9 or more rebuild attempts\\\, giving up\\\")\\n            break\\n        end\\n    end\\n    CI(1)\\n    return Foundone\\nend\\n-- end rebuild section\\n\\n-- section to compute segmentscore(part)s\\nfunction getPartscore(ss\\\,se\\\,attr)\\n    local s=0\\n    if attr=='total' then\\n        s=Score()\\n    elseif attr==nil then --is only called from findWorst\\n        for i=ss\\\,se do\\n            s=s+SegmentScores[i]\\n        end\\n    elseif attr=='loctotal' then --total segment scores\\n        s=GetSubscore(nil\\\,ss\\\,se)\\n    elseif attr=='ligand' then --ligand score\\n        for i=segCnt2+1\\\,segCnt do s=s+current.GetSegmentEnergyScore(i) end\\n    else\\n        s=GetSubscore(attr\\\,ss\\\,se)\\n    end\\n    return s\\nend\\n\\nfunction InitWORKONbool()\\n    WORKONbool=SegmentSetToBool(WORKON)\\nend\\n\\nfunction MustWorkon(i\\\,j)\\n    for k=i\\\,j do if not WORKONbool[k] then return false end end\\n    return true\\nend\\n\\nfunction GetSegmentScores()\\n    if lastSegScores~=Score() then\\n        lastSegScores=Score()\\n        for i=1\\\,segCnt2 do\\n            if WORKONbool[i] then\\n                if \\\#scrPart==0 then\\n                    -- if nothing specified by user default is\\n                    -- segmentenergy - reference + extra Density score\\n                    SegmentScores[i]=current.GetSegmentEnergyScore(i)\\n                    if not structure.IsMutable(i) then --ignore reference part but NOT for mutables)\\n                        SegmentScores[i]=SegmentScores[i]-current.GetSegmentEnergySubscore(i\\\,'reference')\\n                    end\\n                    if math.abs(DENSITYWEIGHT) > 0 then --the Density component has extra weight\\n                        SegmentScores[i]=SegmentScores[i]+DENSITYWEIGHT*current.GetSegmentEnergySubscore(i\\\,'density')\\n                    end\\n                else\\n                    SegmentScores[i]=GetSubscore(scrPart\\\,i\\\,i)\\n                end\\n            end\\n        end\\n    end\\nend\\n-- end section segmentscore(part)s\\n\\n-- Administration of the different slots and best scores\\nScores={} --{save_no\\\,points\\\,totscore\\\,showlist\\\,todo\\\,rbnr}\\n\\n-- Compute which scoreparts to use\\nActiveSub=FindActiveSubscores(true)\\n\\nScoreParts={ --{save_no\\\,name\\\,active}\\n    {4\\\,'total'\\\,true}\\\,\\n    {5\\\,'loctotal'\\\,true}\\n}\\nnextslot=6\\nif HASLIGAND then\\n    ScoreParts[\\\#ScoreParts+1] = { nextslot\\\,'ligand'\\\,true }\\n    nextslot=nextslot+1\\n    print(\\\"Ligand slot enabled\\\")\\nend\\n\\nfor i=1\\\,\\\#ActiveSub do\\n    if ActiveSub[i] ~='Reference' then\\n        ScoreParts[\\\#ScoreParts+1] = { nextslot\\\,ActiveSub[i]\\\,true }\\n        nextslot=nextslot+1\\n    end\\nend\\n\\nfunction ClearScores()\\n    Scores={}\\n    for i=1\\\,\\\#ScoreParts do\\n        if ScoreParts[i][3] then\\n            Scores[\\\#Scores+1]={ScoreParts[i][1]\\\,-9999999\\\,-9999999\\\,''\\\,false\\\,-1}\\n        end\\n    end\\n    slotScr={}\\nend\\n\\nfunction SaveScores(ss\\\,se\\\,RBnr)\\n    local scr={}\\n    for i=1\\\,\\\#ScoreParts do\\n        if ScoreParts[i][3] then\\n            scr[\\\#scr+1]={ScoreParts[i][1]\\\,getPartscore(ss\\\,se\\\,ScoreParts[i][2])}\\n        end\\n    end\\n    local totscore=Score()\\n    for i=1\\\,\\\#Scores do\\n        local s=scr[i][2]\\n        if s>Scores[i][2] then\\n            local slot=scr[i][1]\\n            save.Quicksave(slot) --print(\\\"Saved slot \\\"\\\,slot\\\,\\\" pts\\\" \\\,s) --debug\\n            Scores[i][2]=s\\n            Scores[i][3]=totscore\\n            Scores[i][6]=RBnr\\n        end\\n    end\\n    SaveBest()\\nend\\n\\nfunction ListSlots()\\n    --Give overview of slot occupation\\n    --And sets which slots to process\\n    local Donelist={}\\n    for i=1\\\,\\\#Scores do Donelist[i]=false end\\n    local Report=\\\"\\\"\\n    for i=1\\\,\\\#Scores do if not Donelist[i] then\\n        local Curlist=\\\" \\\"..Scores[i][1]\\n        Scores[i][5]=true --This one we have to process\\n        -- Now find identical filled slots\\n        for j=i+1\\\,\\\#Scores do if Scores[j][3] == Scores[i][3] then\\n            Curlist=Curlist..\\\"=\\\"..Scores[j][1]\\n            Donelist[j]=true\\n        end end\\n        Scores[i][4]=Curlist\\n        Report=Report..\\\" \\\"..Curlist\\n    end end\\n    print(\\\"Slotlist:\\\"..Report)\\nend\\n-- end of administration of slots and scores\\n\\nfunction PrintAreas()\\n    if \\\#areas<19 then\\n        local a=\\\"\\\"\\n        local x=0\\n        for i=1\\\,\\\#areas do\\n            x=x+1\\n            a=a..areas[i][1]..\\\"-\\\"..areas[i][2]..\\\" \\\"\\n            if x>6 then\\n                print(a)\\n                a=\\\"\\\"\\n                x=0\\n            end\\n        end\\n        if x>0 then print(a) end\\n    else\\n        print(\\\"It is \\\"..\\\#areas..\\\" places\\\, not listing.\\\")\\n    end\\nend\\n\\nfunction AddLoop(sS)\\n    local ss=sS\\n    local ssStart=structure.GetSecondaryStructure(ss)\\n    local se=ss\\n    for i=ss+1\\\,segCnt2 do\\n        if structure.GetSecondaryStructure(i)==ssStart then se=i\\n        else break end\\n    end\\n    if se-ss+2>minLen and loops==true then\\n        areas[\\\#areas+1]={ss\\\,se}\\n    end\\n    return se\\nend\\n\\nfunction AddOther(sS)\\n    local ss=sS\\n    local ssStart=structure.GetSecondaryStructure(ss)\\n\\n    local se=ss\\n    if ss>1 then\\n        for i=ss-1\\\,1\\\,-1 do --search bacward for start\\n            local sec=structure.GetSecondaryStructure(i)\\n            if sec==\\\"L\\\" then ss=i\\n            else break end\\n        end\\n    end\\n    if se<segCnt2-1 then --now forward to find end\\n        local change=false\\n        repeat\\n            se=se+1\\n            if se==segCnt2 then break end\\n            local sec=structure.GetSecondaryStructure(se)\\n            if change==false then\\n                if sec~=ssStart then change=true end\\n            end\\n        until change==true and sec~=\\\"L\\\"\\n        if se<segCnt2 then se=se-1 end\\n    end\\n    if sheets==false and ssStart==\\\"E\\\" then return se end\\n    if helices==false and ssStart==\\\"H\\\" then return se end\\n    if se-ss+2>minLen then\\n        areas[\\\#areas+1]={ss\\\,se}\\n    end\\n    return se\\nend\\nfunction FindAreas()\\n    if loops then\\n        local done=false\\n        local ss=0\\n        repeat--loops\\n            ss=ss+1\\n            local ses=structure.GetSecondaryStructure(ss)\\n            if ses==\\\"L\\\" then\\n                ss=AddLoop(ss)\\n            end\\n            if ss==segCnt2 then done=true end\\n        until done~=false\\n    end\\n    if sheets or helices then\\n        local done=false\\n        local ss=0\\n        repeat--other\\n            ss=ss+1\\n            local ses=structure.GetSecondaryStructure(ss)\\n            if ses~=\\\"L\\\" then\\n                ss=AddOther(ss)\\n            end\\n            if ss==segCnt2 then done=true end\\n        until done~=false\\n    end\\nend\\n\\nfirstRBseg=0\\nlastRBseg=0\\n\\nfunction MutateSel(maxitter)\\n    if maxitter == nil then maxitter=2 end\\n    structure.MutateSidechainsSelected(maxitter)\\nend\\n\\nfunction MutateAll(maxitter)\\n    selection.SelectAll()\\n    MutateSel(maxitter)\\nend\\n\\nfunction doMutate()\\n    if not HASMUTABLE then return end\\n    -- Do not accept loss if mutating\\n    local curscore=Score()\\n    PushPosition()\\n    CI(MutateCI)\\n    Bridgesave()\\n    if MUTRB then\\n        selection.DeselectAll()\\n        selection.SelectRange(firstRBseg\\\,lastRBseg)\\n        MutateSel()\\n    elseif MUTSur then\\n        SelectAround(firstRBseg\\\,lastRBseg\\\,MutSphere)\\n        MutateSel()\\n    else\\n        MutateAll()\\n    end\\n    Bridgerestore()\\n    if Score() < curscore then PopPosition() else ClrTopPosition() end\\nend\\n\\nfunction DeepRebuild()\\n    local ss=Score()\\n    if struct==false then AllLoop() end\\n    save.Quicksave(3)\\n    recentbest.Save()\\n    print(\\\"DeepRebuild started at score: \\\"..round3(ss))\\n\\n    for i=1\\\,\\\#areas do\\n        local ss1=Score()\\n        local s=areas[i][1]\\n        local e=areas[i][2]\\n        local CurrentHigh=0\\n        local CurrentAll=\\\"\\\" -- to report where gains came from\\n        local CurrentHighScore= -99999999\\n        firstRBseg=s\\n        lastRBseg=e\\n        Bridgesave()\\nif Runnr > 0 then --Runnr 0 is to skip worst parts\\n        print(\\\"DR \\\"..Runnr..\\\".\\\"..(e-s+1)..\\\".\\\"..i..\\\" \\\"..s..\\\"-\\\"..e..\\\" \\\"..\\n              rebuilds..\\\" times. Wait... Current score: \\\"..round3(Score()))\\n        if ReBuild(s\\\,e\\\,rebuilds) then\\n            -- Make sure we do not miss an improvement during rebuild\\n            if RBScore() > bestScore then\\n                Bridgesave()\\n                recentbest.Restore()\\n                Bridgerestore()\\n                if Score() > bestScore+0.00001 then\\n                    print(\\\"Found a missed gain!!!\\\")\\n                    SaveScores(s\\\,e\\\,0)\\n                end\\n            end\\n            ListSlots()\\n            for r=1\\\,\\\#Scores do\\n                if Scores[r][5] then\\n                    local slot=Scores[r][1]\\n                    save.Quickload(slot)\\n                    SelectAround(s\\\,e\\\,12) --local shake after rebuild\\n                    Bridgesave()\\n                    if not skipqstab then qStab()\\n                    else\\n                        CI(1)\\n                        Wiggle(\\\"s\\\"\\\,1\\\,nil\\\,true)\\n                        Wiggle(\\\"ws\\\"\\\,1\\\,nil\\\,true)\\n                    end\\n                    Bridgerestore()\\n                    if AfterQstab then doMutate() end\\n                    save.Quicksave(slot)\\n                    if Score() > CurrentHighScore then\\n                         CurrentHigh=slot\\n                         CurrentAll=Scores[r][4]..\\\"(RB\\\"..Scores[r][6]..\\\")\\\"\\n                         CurrentHighScore=Score()\\n                    end\\n                    SaveBest()\\n                    print(\\\"Stabilized slot \\\"..slot..\\\" Score: \\\"..round3(Score()))\\n                end\\n            end\\n            save.Quickload(CurrentHigh)\\n            if not skipfuze and ss1-Score() < maxlossbeforefuze*(e-s+1)/3 then\\n                print(\\\"Fuzing best position.\\\")\\n                if not AfterQstab and BeFuze then doMutate() end\\n                save.Quicksave(4)\\n                if savebridges then Fuze(4\\\,Bridgesave\\\,Bridgerestore\\\,localshakes) else Fuze(4\\\,nil\\\,nil\\\,localshakes) end\\n                if AfterFuze then doMutate() end\\n            end\\n            SaveBest()\\n            save.Quickload(3)\\n        else save.Quickload(3) end\\nend --skip section\\n        if savebridges then\\n            if BridgesBroken() then\\n                -- THIS SHOULD NOT HAPPEN\\n                print(\\\"Unexpected bridge broken\\\, pls report\\\\n\\\")\\n                print(\\\"Restoring a good position\\\, discarding wins\\\\n\\\")\\n                Bridgerestore()\\n                save.Quicksave(3)\\n                bestScore=Score()\\n            else Bridgerestore()\\n            end\\n        else Bridgerestore() end\\n        if ss1+0.00001 < Score() then\\n            print(\\\"Gain from slots \\\"\\\,CurrentAll)\\n        end\\n        AddDone(s\\\,e)\\n        ChkDoneList()\\n        if Score()-ss > minGain then break end\\n\\n    end\\n    print(\\\"DeepRebuild gain: \\\"..round3(Score()-ss))\\n    if struct==false and SAVEDstructs then save.LoadSecondaryStructure() end\\nend\\n\\nfunction DRcall(how)\\n    if how==\\\"drw\\\" then\\n        local stepsize=1\\n        if minLen>maxLen then stepsize= -1 end\\n        for i=minLen\\\,maxLen\\\,stepsize do --search from minl to maxl worst segments\\n            len=i\\n            FindWorst(true) --fill areas table. Comment it if you have set them by hand\\n            PrintAreas()\\n            DeepRebuild()\\n\\n        end\\n    elseif how==\\\"fj\\\" then --DRW len cutted on pieces\\n        FindWorst(true) --add to areas table worst part\\n        areas2={}\\n        for a=1\\\,\\\#areas do\\n            local s=areas[a] --{ss\\\,se}\\n            local ss=s[1] --start segment of worst area\\n            local se=s[2] --end segment of worst area\\n            for i=ss\\\,se do\\n                for x=1\\\,len do\\n                    if i+x<=se then\\n                        areas2[\\\#areas2+1]={i\\\,i+x}\\n                    end\\n                end\\n            end\\n        end\\n        areas=areas2\\n        PrintAreas()\\n        DeepRebuild()\\n    elseif how==\\\"all\\\" then\\n        areas={}\\n        for i=minLen\\\,maxLen do\\n            for x=1\\\,segCnt2 do\\n                if i+x-1<=segCnt2 then\\n                    areas[\\\#areas+1]={x\\\,x+i-1}\\n                end\\n            end\\n        end\\n        PrintAreas()\\n        DeepRebuild()\\n    elseif how==\\\"simple\\\" then\\n        FindWorst(true)\\n        PrintAreas()\\n        DeepRebuild()\\n    elseif how==\\\"areas\\\" then\\n        areas={}\\n        FindAreas()\\n        PrintAreas()\\n        DeepRebuild()\\n    end\\nend\\n\\nfunction AskMoreOptions()\\n    local ask=dialog.CreateDialog(\\\"More DRW options\\\")\\n    ask.fastQstab=dialog.AddCheckbox(\\\"Do a fast qStab\\\"\\\,fastQstab)\\n    ask.ll3 = dialog.AddLabel(\\\"Force next round if gain is more\\\")\\n    ask.minGain = dialog.AddSlider(\\\"MinGain:\\\"\\\,minGain\\\,0\\\,500\\\,0)\\n    ask.ll4 = dialog.AddLabel(\\\"Skip fuze if loss is more\\\")\\n    ask.ll5 = dialog.AddLabel(\\\"Threshold used is RBlength*threshold/3\\\")\\n    ask.maxLoss = dialog.AddSlider(\\\"Skip fuze:\\\"\\\,maxlossbeforefuze\\\,-5\\\,200\\\,0)\\n    ask.donotrevisit = dialog.AddCheckbox(\\\"Do not things twice\\\"\\\,donotrevisit)\\n    ask.l1=dialog.AddLabel(\\\"Clear no revisit list if gain is more\\\")\\n    ask.revlist=dialog.AddSlider(\\\"Cleargain:\\\"\\\,clrdonelistgain\\\,0\\\,500\\\,0)\\n    ask.l2=dialog.AddLabel(\\\"Number of rebuilds each pass\\\")\\n    ask.nrrebuilds=dialog.AddSlider(\\\"Rebuilds:\\\"\\\,rebuilds\\\,1\\\,100\\\,0)\\n    ask.reBuild=dialog.AddSlider(\\\"\\\#in first cycle:\\\"\\\,reBuild\\\,1\\\,segCnt2\\\,0)\\n    ask.reBuildm=dialog.AddSlider(\\\"\\\#add each cycle:\\\"\\\,reBuildmore\\\,0\\\,4\\\,0)\\n    ask.doSpecial=dialog.AddCheckbox(\\\"Local cleanup after rebuild SLOW\\\"\\\,doSpecial)\\n    ask.doShake=dialog.AddCheckbox(\\\"Or Shake after rebuild\\\"\\\,doShake)\\n    ask.shakeCI=dialog.AddSlider(\\\"Shake CI:\\\"\\\,shakeCI\\\,0\\\,1\\\,2)\\n    ask.skipqstab=dialog.AddCheckbox(\\\"Local shake instead of Qstab\\\"\\\,skipqstab)\\n    ask.skipfuze=dialog.AddCheckbox(\\\"Skip Fuze\\\"\\\,skipfuze)\\n    ask.OK = dialog.AddButton(\\\"OK\\\"\\\,1)\\n    dialog.Show(ask)\\n    fastQstab=ask.fastQstab.value\\n    minGain=ask.minGain.value\\n    maxlossbeforefuze=ask.maxLoss.value\\n    clrdonelistgain=ask.revlist.value\\n    rebuilds=ask.nrrebuilds.value\\n    reBuild=ask.reBuild.value\\n    reBuildmore=ask.reBuildm.value\\n    doShake=ask.doShake.value\\n    doSpecial=ask.doSpecial.value\\n    shakeCI=ask.shakeCI.value\\n    skipqstab=ask.skipqstab.value\\n    donotrevisit=ask.donotrevisit.value\\n    skipfuze=ask.skipfuze.value\\nend\\n\\nfunction AskMutateOptions()\\n    local ask = dialog.CreateDialog(\\\"Mutate Options\\\")\\n    ask.AfterRB = dialog.AddCheckbox(\\\"Mutate after rebuild\\\"\\\,AfterRB)\\n    ask.InQstab = dialog.AddCheckbox(\\\"Mutate during Qstab\\\"\\\,InQstab)\\n    ask.AfterQstab = dialog.AddCheckbox(\\\"Mutate after Qstab\\\"\\\,AfterQstab)\\n    ask.BeFuze = dialog.AddCheckbox(\\\"Mutate before Fuze\\\"\\\,BeFuze)\\n    ask.AfterFuze = dialog.AddCheckbox(\\\"Mutate after Fuze\\\"\\\,AfterFuze)\\n    ask.l1=dialog.AddLabel(\\\"-----What to rebuild\\\, last one counts or all\\\")\\n    ask.OnlyRB=dialog.AddCheckbox(\\\"Mutate only rebuild part\\\"\\\,MUTRB)\\n    ask.OnlySur=dialog.AddCheckbox(\\\"Mutate rebuild and surround\\\"\\\,MUTSur)\\n    ask.l2=dialog.AddLabel(\\\"Sphere size to use with surround\\\")\\n    ask.SurSize=dialog.AddSlider(\\\"Sphere:\\\"\\\,MutSphere\\\,3\\\,15\\\,0)\\n    ask.MutateCI=dialog.AddSlider(\\\"MutateCI:\\\"\\\,MutateCI\\\,0.1\\\,1\\\,2)\\n    ask.OK = dialog.AddButton(\\\"OK\\\"\\\,1) ask.Cancel = dialog.AddButton(\\\"Cancel\\\"\\\,0)\\n    if dialog.Show(ask) > 0 then\\n        AfterRB=ask.AfterRB.value\\n        InQstab=ask.InQstab.value\\n        AfterQstab=ask.AfterQstab.value\\n        BeFuze=ask.BeFuze.value\\n        AfterFuze=ask.AfterFuze.value\\n        MutateCI=ask.MutateCI.value\\n        MutSphere=ask.SurSize.value\\n        MUTRB=ask.OnlyRB.value\\n        MUTSur=ask.OnlySur.value\\n        if MUTSur then MUTRB=false end\\n    end\\nend\\n\\nfunction printOptions(title)\\n    print(title..\\\" Based on rav4pl DRW 3.4\\\")\\n    print(\\\"Length of rebuilds: \\\"..minLen..\\\" to \\\"..maxLen)\\n    print(\\\"Rebuild area: \\\"..SegmentSetToString(WORKON))\\n    print(\\\"Nr of rebuilds each try: \\\"..rebuilds)\\n    if WF>1 then print(\\\"Wiggle factor \\\"..WF) end\\n    if not struct then print(\\\"Convert everything to loops\\\") end\\n    if not donotrevisit then print(\\\"Will retry already tried rebuilds\\\")\\n    else\\n        print(\\\"Clear retry blockings if gain raises above \\\"..clrdonelistgain..\\\" pts\\\")\\n    end\\n    if doSpecial then print(\\\"Local cleanup after rebuild\\\")\\n    elseif doShake then\\n        print(\\\"Initial shake after rebuild\\\"..\\\"with CI=\\\"..shakeCI)\\n    end\\n    if skipqstab then print(\\\"Local shake instead of qStab\\\") end\\n    if skipfuze then print(\\\"Skipping Fuzes\\\") end\\n    print(\\\"Nr of full cycles: \\\"..maxnrofRuns)\\n    if nrskip > 0 then print(\\\"SKIPPING \\\"..nrskip..\\\" worst segmentparts\\\") end\\n    if disjunct then print(\\\"Running in disjunct mode\\\") end\\nend\\n\\nfunction AskSubScores()\\n    local ask = dialog.CreateDialog(\\\"Slot selection DRW \\\"..DRWVersion)\\n    ask.l1=dialog.AddLabel(\\\"Specify which slots based on scorepart to use\\\")\\n    for i=1\\\,\\\#ScoreParts do\\n        ask[ScoreParts[i][2]]=dialog.AddCheckbox(ScoreParts[i][1]..\\\" \\\"..ScoreParts[i][2]\\\,ScoreParts[i][3])\\n    end\\n    ask.OK = dialog.AddButton(\\\"OK\\\"\\\,1) ask.Cancel = dialog.AddButton(\\\"Cancel\\\"\\\,0)\\n    if dialog.Show(ask) > 0 then\\n      for i=1\\\,\\\#ScoreParts do ScoreParts[i][3]=ask[ScoreParts[i][2]].value end\\n    end\\nend\\n\\nfunction AskSelScores()\\n    local ask = dialog.CreateDialog(\\\"Set worst searching DRW \\\"..DRWVersion)\\n    ask.l1=dialog.AddLabel(\\\"Specify which worst subscoretotal(s) to count\\\")\\n    for i=3\\\,\\\#ScoreParts do\\n        ask[ScoreParts[i][2]]=dialog.AddCheckbox(ScoreParts[i][2]\\\,false)\\n    end\\n    ask.OK = dialog.AddButton(\\\"OK\\\"\\\,1) ask.Cancel = dialog.AddButton(\\\"Cancel\\\"\\\,0)\\n    scrPart={}\\n    if dialog.Show(ask) > 0 then\\n      for i=3\\\,\\\#ScoreParts do\\n        if ask[ScoreParts[i][2]].value then scrPart[\\\#scrPart+1]=ScoreParts[i][2] end\\n      end\\n    end\\nend\\n\\nfunction AskDRWOptions()\\n    local askresult\\n    local askmutable=HASMUTABLE\\n    local ask = dialog.CreateDialog(\\\"Tvdl enhanced DRW \\\"..DRWVersion)\\n    if askmutable then\\n        print(\\\"Setting default mutate options\\\")\\n        AfterQstab=true\\n        AfterFuze=true\\n        MutSur=true\\n    end\\nrepeat\\n    ask.l1 = dialog.AddLabel(\\\"Length to rebuild\\\, From can be bigger than To\\\")\\n    ask.minLen = dialog.AddSlider(\\\"From length:\\\"\\\,minLen\\\,1\\\,10\\\,0)\\n    ask.maxLen = dialog.AddSlider(\\\"To length:\\\"\\\,maxLen\\\,1\\\,10\\\,0)\\n    ask.lll=dialog.AddLabel(\\\"Wiggle more when CI is on its maximum\\\")\\n    ask.WF = dialog.AddSlider(\\\"WiggleFactor:\\\"\\\,WF\\\,1\\\,5\\\,0)\\n    ask.slotl=dialog.AddLabel(\\\"Slot selection\\\, last choice counts\\\")\\n    ask.selall=dialog.AddCheckbox(\\\"All slots\\\"\\\,SlotAll)\\n    ask.sel4=dialog.AddCheckbox(\\\"4 main slots\\\, faster\\\"\\\,Slot4)\\n    ask.selSP= dialog.AddCheckbox(\\\"(Re)select slots\\\"\\\,false)\\n\\n    ask.ll3=dialog.AddLabel(\\\"Number of full cycles\\\")\\n    ask.nrcycles=dialog.AddSlider(\\\"Cycles:\\\"\\\,maxnrofRuns\\\,1\\\,40\\\,0)\\n\\n    ask.ll4=dialog.AddLabel(\\\"Skip first worst parts (crash resume)\\\")\\n    ask.nrskip=dialog.AddSlider(\\\"Skip parts:\\\"\\\,nrskip\\\,0\\\,segCnt2\\\,0)\\n    ask.SEL= dialog.AddCheckbox(\\\"(Re)select where to work on \\\"\\\,false)\\n    if HASMUTABLE then\\n        ask.MUTS = dialog.AddCheckbox(\\\"(Re)set Mutate Options\\\"\\\,askmutable)\\n    end\\n    ask.localshakes=dialog.AddCheckbox(\\\"Do shakes only local\\\"\\\,localshakes)\\n    ask.worst= dialog.AddCheckbox(\\\"(Re)set worst search params\\\"\\\,false)\\n    if nrofbridges > 1 then ask.bridge = dialog.AddCheckbox(\\\"Keep sulfide bridges intact\\\"\\\,savebridges) end\\n    ask.struct = dialog.AddCheckbox(\\\"Do not change all to loop\\\"\\\,struct)\\n    ask.l6=dialog.AddLabel(\\\"Search only for disjunct from previous done\\\")\\n    ask.disjunct=dialog.AddCheckbox(\\\"Disjunct\\\"\\\,disjunct)\\n    ask.bandflip=dialog.AddCheckbox(\\\"Disable bands during rebuild AND enable after\\\"\\\,bandflip)\\n    ask.OK = dialog.AddButton(\\\"OK\\\"\\\,1) ask.Cancel = dialog.AddButton(\\\"Cancel\\\"\\\,0)\\n    ask.Options = dialog.AddButton(\\\"More options\\\"\\\,2)\\n    askresult=dialog.Show(ask)\\n    if askresult > 0 then\\n        minLen=ask.minLen.value\\n        maxLen=ask.maxLen.value\\n\\n        maxnrofRuns=ask.nrcycles.value\\n\\n        nrskip=ask.nrskip.value\\n        bandflip=ask.bandflip.value\\n        disjunct=ask.disjunct.value\\n        struct=ask.struct.value\\n        WF=ask.WF.value\\n        SlotAll=ask.selall.value\\n        if SlotAll then\\n            for i=1\\\,\\\#ScoreParts do ScoreParts[i][3]=true end\\n        end\\n        Slot4=ask.sel4.value\\n        if Slot4 then\\n            for i=1\\\,\\\#ScoreParts do\\n                if ScoreParts[i][1] == 4 then ScoreParts[i][3]=true\\n                elseif ScoreParts[i][2] == 'Backbone' then ScoreParts[i][3]=true\\n                elseif ScoreParts[i][2] == 'Hiding' then ScoreParts[i][3]=true\\n                elseif ScoreParts[i][2] == 'Packing' then ScoreParts[i][3]=true\\n                else ScoreParts[i][3]=false end\\n            end\\n        end\\n        localshakes=ask.localshakes.value\\n        if nrofbridges > 1 then savebridges=ask.bridge.value end\\n        if ask.SEL.value then\\n            Slot4=false\\n            SlotAll=false\\n            local SelMode={}\\n            SelMode.askignorefrozen=false\\n            SelMode.defignorefrozen=true\\n            SelMode.askignorelocks=false\\n            SelMode.defignorelocks=true\\n            SelMode.askligands=false\\n            SelMode.defligands=false\\n            WORKON=AskForSelections(\\\"Tvdl enhanced DRW \\\"..DRWVersion\\\,SelMode)\\n            print(\\\"Selection is now\\\, reselect if not oke:\\\")\\n            print(SegmentSetToString(WORKON))\\n            if askresult==1 then askresult=4 end --to force return to main menu\\n        end\\n        if ask.selSP.value then\\n            AskSubScores()\\n            if askresult==1 then askresult=4 end\\n        end\\n        for i=1\\\,\\\#ScoreParts do if ScoreParts[1][3] then\\n            print(\\\"Active slot \\\"..ScoreParts[i][1]..\\\" is \\\"..ScoreParts[i][2])\\n        end end\\n        if ask.worst.value then\\n            AskSelScores()\\n            if askresult==1 then askresult=4 end\\n        end\\n        -- Do not try to rebuild frozen or locked parts or ligands\\n        WORKON=SegmentSetMinus(WORKON\\\,FindFrozen())\\n        WORKON=SegmentSetMinus(WORKON\\\,FindLocked())\\n        WORKON=SegmentSetMinus(WORKON\\\,FindAAtype(\\\"M\\\"))\\n        if HASMUTABLE then if ask.MUTS.value then\\n            AskMutateOptions()\\n            askmutable=false\\n            if askresult==1 then askresult=4 end --to force return to main menu\\n        end end\\n        if HASMUTABLE then\\n           print(\\\"Mutate options are now:\\\")\\n           local Mess=\\\"Mutates \\\"\\n           if AfterRB then Mess=Mess..\\\"after each rebuild\\\, \\\" end\\n           if InQstab then Mess=Mess..\\\"inside qStab\\\, \\\" end\\n           if AfterQstab then Mess=Mess..\\\"after qStab\\\, \\\" end\\n           if BeFuze then Mess=Mess..\\\"before Fuzing\\\, \\\" end\\n           if AfterFuze then Mess=Mess..\\\"after Fuzing.\\\" end\\n           print(Mess)\\n           Mess=\\\"Mutate area \\\"\\n           if MUTRB then Mess=Mess..\\\"is Rebuild parts only\\\"\\n           elseif MUTSur then Mess=Mess..\\\"is Rebuild part and surroundings\\\"\\n           else Mess=Mess..\\\"is the whole protein\\\" end\\n           print(Mess)\\n        end\\n        if askresult==2 then AskMoreOptions() end\\n    end\\nuntil askresult < 2\\n    return askresult > 0\\nend\\n-- Quick fix for failing first rebuild\\nfor i=3\\\,12 do save.Quicksave(i) end\\n\\n--[[\\n    USAGE\\n1. 'drw' - need 'minLen' and 'maxLen'; finding worst scores by len betwen that 2\\n2. 'fj' - need 'len'; searching len then cutting in pieces 2->len and rebuilds pieces\\n3. 'all' - need 'minLen' and 'maxLen'; rebuilding ENTIRE prorein (from min to max) like in WalkinRebuild script\\n4. 'simple' - need 'len'; find and rebuild worst scoring parts of that lenght\\n5. 'areas' - need secondary structure set and 'true' on at least one of structure\\n]]--\\n----------------- options below VVVV\\n\\nareas={ --start segment\\\, end segment. use for last line call\\n--{1\\\,10}\\\,\\n--{20\\\,30}\\\,\\n--{32\\\,35}\\\,\\n}\\nscrPart={}\\n\\n--options for (5)\\\"areas\\\" setting\\nloops=true --rebuild loops alone\\nsheets=false --rebuild sheets + surrounding loops\\nhelices=true --false --rebuild helices + surrounding loops\\n\\ndoShake=true --false --shake rebuilded area (only!) every rebuild\\\, slowing down process\\ndoSpecial=false -- local shake\\\, wiggle sidec\\\, wiggle backbone\\\, even slower\\nshakeCI=0.31 --clash imortance while shaking\\n\\nstruct=false --set in all loop (if true work in structure mode)\\n\\nfastQstab=true --false --if true faster stabilize\\\, but longer\\n\\nreBuild=4 --up to worst parts to look at\\nreBuildmore=1 --increased by every main cycle\\nrebuilds=15 --how many rebuilds to try\\\, set at least 10!\\n\\nfunction askAUNT()\\n    local ask=dialog.CreateDialog(\\\"HI Auntdeen\\\")\\n    ask.l1=dialog.AddLabel(\\\"Set number of rebuilds\\\")\\n    ask.l2=dialog.AddLabel(\\\"Low    15\\\")\\n    ask.l3=dialog.AddLabel(\\\"Medium 25\\\")\\n    ask.l4=dialog.AddLabel(\\\"High   40\\\")\\n    ask.low=dialog.AddButton(\\\"Low\\\"\\\,1)\\n    ask.med=dialog.AddButton(\\\"Medium\\\"\\\,2)\\n    ask.high=dialog.AddButton(\\\"High\\\"\\\,3)\\n    local result=dialog.Show(ask)\\n    if result==1 then rebuilds=15\\n    elseif result==2 then rebuilds=25\\n    else rebuilds=40 end\\nend\\n\\nif ISAUNTDEEN then\\n    askAUNT()\\nend\\nrebuildCI=0 --clash importance while rebuild\\n\\nlen=6 --find worst segments part\\nminLen=2 --or specify minimum len\\nmaxLen=4 --and maximim len\\n\\n-- New options\\nmaxnrofRuns=40 -- Set it very high if you want to run forever\\nRunnr=0\\nminGain=(segCnt2-segCnt2%4)/4 -- If less gain then try the next one\\\, else recompute\\nif minGain < 40 then minGain=40 end\\nskipqstab=false\\nskipfuze=false\\nbandflip= band.GetCount() > 0\\nmaxlossbeforefuze=(segCnt2-segCnt2%4)/4 -- if loss is more no fuze is done\\nif maxlossbeforefuze < 30 then maxlossbeforefuze=30 end\\nnrskip=0\\nlocalshakes=true\\nAfterRB=false\\nInQstab=false\\nAfterQstab=false\\nBeFuze=false\\nAfterFuze=false\\nMutateCI=0.9\\nMutSphere=8\\nMUTRB=false\\nMUTSur=false\\nif HASMUTABLE then\\n    AfterQstab=true\\n    AfterFuze=true\\n    MUTSur=true\\nend\\nSlot4=false\\nSlotAll=true\\nWORKON={{1\\\,segCnt2}}\\n-- part to administrate what has been done\\nDonepart={} --To find fast if to be skipped\\nBlocked={} --A simple list so we can clear Donepart\\nDisj={} --To administrate which segments have be touched\\ndisjunct=false\\ndonotrevisit=true\\nclrdonelistgain=segCnt\\ncurclrscore=Score()\\nWORKONbool={}\\nSegmentScores={} --Optimalisation for fast worst search\\nlastSegScores=0\\nDRWVersion=\\\"2.8.0\\\"\\n\\n-- MAIN PROGRAM\\nfirstDRWcall=true\\nDRWstartscore=0\\nfunction DRW()\\n    if firstDRWcall then\\n        printOptions(\\\"Tvdl enhanced DRW \\\"..DRWVersion)\\n        firstDRWcall=false\\n    end\\n    InitWORKONbool()\\n    DRWstartscore=Score()\\n    if nrskip > 0 then\\n        local sreBuild=reBuild\\n        reBuild=nrskip\\n        Runnr=0\\n        DRcall(\\\"drw\\\")\\n        nrskip=0\\n        reBuild=sreBuild\\n    end\\n\\n    for nrofRuns=1\\\,maxnrofRuns do --uncomment method/s you want to use\\n         Runnr=Runnr+1\\n         print(\\\"Main cycle nr \\\"\\\,Runnr)\\n-- DRcall(\\\"areas\\\")\\n     DRcall(\\\"drw\\\")\\n-- DRcall(\\\"fj\\\")\\n-- DRcall(\\\"all\\\")\\n-- DRcall(\\\"simple\\\")\\n\\n        ChkDoneList()\\n        reBuild=reBuild+reBuildmore\\n    end\\nend\\n\\n-- Change defaults if the startscore is negative\\nif Score() < 4000 then\\n    local adjust=true\\n    if HASDENSITY then\\n        local oscore=GetSubscore(\\\"density\\\")\\n        if Score()-oscore*(DENSITYWEIGHT+1) > 4000 then\\n            adjust=false\\n            print(\\\"ED puzzle\\\, score high enough not counting ED\\\")\\n            print(\\\"so no auto blocking of qstab and fuze\\\")\\n        end\\n    end\\n    if adjust then\\n        print(\\\"Score < 4000\\\, adjusting defaults\\\")\\n        print(\\\"Now skipping Fuzes\\\, replacing qStab\\\")\\n        print(\\\"Can be changed in More options\\\")\\n        skipfuze=true\\n        skipqstab=true\\n    end\\nend\\n\\nSAFEselection=FindSelected()\\n\\nif AskDRWOptions() then\\n    xpcall(DRW\\\,Cleanup)\\nend\\n\\n\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"1\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1340026344" : "{\n \"desc\" : \"Exploratory RB on segments by stride. Press Ctrl+N to restore best pose.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"XPRB (BY-STRIDE) - SG\"\n \"parent\" : \"101702\"\n \"parent_mrid\" : \"202318\"\n \"player_id\" : \"0\"\n \"script\" : \"-- LWS-SG --\\nfunction selection.SelectNeighbor(start\\\,stop\\\,dist)\\n  local k = structure.GetCount()\\n  for i=1\\\,k do\\n    if selection.IsSelected(i)==false then\\n      for j=start\\\,stop do\\n        if math.abs(structure.GetDistance(i\\\,j))<dist then\\n           selection.Select(i)\\n           break\\n        end\\n      end -- loopf\\n    end -- testi\\n  end -- loopf\\nend\\nfunction structure.Fuze()\\n  behavior.SetClashImportance(.1)\\n  structure.WiggleAll(1)\\n  behavior.SetClashImportance(1)\\n  structure.WiggleAll(1)\\nend\\nfunction structure.SmartWiggle (s)\\n  local min_gain = 1\\n  local gain_found = true\\n  while(gain_found) do\\n    local s_0 = current.GetScore()\\n    structure.WiggleAll(s)\\n    gain_found = current.GetScore() > s_0 + min_gain\\n  end -- loopw\\nend\\nfunction _main_()\\n  local stride = 2\\n  local boost = 2\\n  local k = structure.GetCount()-stride\\n  local segs = structure.GetCount()\\n  local s0 = current.GetScore()\\n  local s1 = current.GetScore()\\n  local maxstride = 8\\n  local iters = 1\\n  local start = 1\\n  local spread = 2\\n  local thresh = 0.001\\n  local fuze_thresh = 40\\n  print('XP RB-SG script\\\\nSegments: '..segs..'\\\\n')\\n  recentbest.Save()\\n  print('Score: '..s0..'\\\\n')\\n  while(1) do\\n    while(stride<maxstride) do\\n      print('Stride: +'..stride..'\\\\n')\\n      for i=start\\\,k do\\n        for j=1\\\,10 do\\n          selection.DeselectAll()\\n          selection.SelectRange(i\\\,(i+stride) or segs)\\n          structure.RebuildSelected(iters)\\n          selection.SelectNeighbor(i\\\,(i+stride) or segs\\\,9)\\n          structure.ShakeSidechainsSelected(iters)\\n          if current.GetScore()<0 then\\n            behavior.SetClashImportance(.1)\\n            structure.WiggleAll(1)\\n            behavior.SetClashImportance(1)\\n          end\\n          local s2 = current.GetScore()\\n          structure.SmartWiggle(iters)\\n          s1 = current.GetScore()\\n          if s1-s2<1 then\\n            structure.LocalWiggleSelected(iters)\\n            structure.SmartWiggle(iters)\\n          end\\n          s1 = current.GetScore()\\n          if s0 ~= s1 and s1+fuze_thresh>s0 then\\n            structure.Fuze()\\n          end\\n        end -- loopf\\n        recentbest.Restore()\\n        s1 = current.GetScore()\\n        if (s1-s0)>thresh then\\n          print('Segments '..i..' - '..(i+stride)..'\\\\n')\\n          print('Gain found: '..s1\\\,' +'..(s1-s0)..'\\\\n')\\n          s0 = s1\\n          save.Quicksave(3)\\n        end\\n      end--loopf\\n      stride = stride + boost\\n      k = segs - stride\\n    end--loopw\\n    stride = 2\\n    k = segs - stride\\n  end--loopw\\nend--func\\n\\nxpcall(_main_\\\,absolutebest.Restore)\\n\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"3\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1362658609" : "{\n \"desc\" : \"v1.7 QS-Fuse from saveslot (1)\\\, compares ws + w + s\\\, s + w + s\\\, wb\\\, etc\\\, and restore recent best. Now includes a smarter shake algorithm. If you abort prematurely\\\, press CTRL + N to restore your best score.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"1\"\n \"mid\" : \"35826\"\n \"mrid\" : \"64388\"\n \"name\" : \"QS-Fuse_v1_7 - Seagat2011\"\n \"parent\" : \"25625\"\n \"parent_mrid\" : \"47845\"\n \"player_id\" : \"199249\"\n \"script\" : \"-- QS-Fuse_v1_7-Seagat2011\\r\\n-- QS-Fuse from saveslot (1)\\\, efficient comparison: ws + w + s\\\, s + w + s\\\, wb\\\, etc\\\, and restore recent best. If you abort prematurely\\\, press CTRL + N to restore your best score.\\r\\n\\r\\nlocal ws_slot = 4\\r\\nlocal sh_slot = 5\\r\\n\\r\\nlocal puzzle = {}\\r\\nlocal qs_fuse = {}\\r\\nlocal stabilize = {}\\r\\nlocal math = {}\\r\\n\\r\\nfunction math.floor ( n\\\,f )\\r\\n    return n - n%f  \\r\\nend -- function _floor\\r\\n\\r\\nfunction puzzle.score ()\\r\\n    return get_ranked_score ( true )\\r\\nend\\r\\n\\r\\npuzzle.ci = set_behavior_clash_importance\\r\\npuzzle.wiggle_all = do_global_wiggle_all\\r\\npuzzle.wiggle_backbone = do_global_wiggle_backbone\\r\\npuzzle.wiggle_sidechains = do_global_wiggle_sidechains\\r\\npuzzle.do_shake = do_shake\\r\\n\\r\\ndo_global_wiggle_all = null\\r\\n\\r\\nlocal function _ws ( r )\\r\\n    if r.ws_skip == false then\\r\\n\\t\\tdo_global_wiggle_sidechains ( 1 )\\r\\n\\t\\tquicksave ( r.ws_slot )\\r\\n\\t\\tr.ws_skip = true\\r\\n\\telse\\r\\n\\t\\tquickload ( r.ws_slot )\\t\\r\\n\\tend\\r\\n\\treturn r\\r\\nend\\r\\n\\r\\nlocal function _sh ( r )\\r\\n    if r.sh_skip == false then\\r\\n\\t\\tdo_shake ( 1 )\\r\\n\\t\\tquicksave ( r.sh_slot )\\t\\r\\n\\t\\tr.sh_skip = true\\r\\n\\telse\\r\\n\\t\\tquickload ( r.sh_slot )\\r\\n\\tend\\r\\n\\treturn r\\r\\nend\\r\\n\\r\\nlocal   hash = {} -- forward declaration DO NOT TOUCH\\r\\nlocal _hash = {} -- forward declaration DO NOT TOUCH\\r\\n\\r\\nfunction hash.map ( key\\\,value )\\r\\n   _hash [ key ] = value\\r\\n    return _hash\\r\\nend -- function hash.map\\r\\n\\r\\nfunction hash.getValue ( key )\\r\\n    return _hash [ key ]\\r\\nend -- hash.getValue \\r\\n\\r\\nfunction hash.empty ()\\r\\n   _hash = {}\\r\\n    return  _hash\\r\\nend -- hash.getValue\\r\\n\\r\\nfunction stabilize.threshHold ()\\r\\n    return 0.9248\\r\\nend\\r\\n\\r\\nfunction stabilize.smartShake ( k )\\r\\n    if puzzle.score () > k*stabilize.threshHold () then\\r\\n        puzzle.do_shake ( 1 )\\r\\n    end\\r\\nend\\r\\n\\r\\nfunction stabilize.do_shake_end ( n )\\r\\n    local a = puzzle.score ()--math.floor ( puzzle.score ()\\\, 0.001 )       \\r\\n    if(hash.getValue ( a ) ~= a) then\\r\\n\\tpuzzle.do_shake (1) \\r\\n\\thash.map ( a\\\,a )\\r\\n    end\\r\\nend\\r\\n\\r\\nfunction puzzle.checkScore ( a\\\,r )\\r\\n    local b = puzzle.score ()\\r\\n    if b > a then\\r\\n        print (  \\\"mode: \\\"\\\, r.mode\\\, \\\"\\\\nGain: \\\"\\\, b\\\, \\\"  + \\\"\\\, b - a )\\r\\n        a = b\\r\\n    end\\r\\n    return a\\r\\nend\\r\\n\\r\\nfunction stabilize.try_stage ( stage\\\,r )\\r\\n    local a\\r\\n    local b\\r\\n    local mode\\r\\n    local score_before_shake\\r\\n    score_before_shake = r.sbs\\r\\n    if ( r.b_firstTime == true ) then\\r\\n        r.b_firstTime = false\\r\\n        quicksave ( 1 )\\r\\n    else\\r\\n        quickload ( 1 )\\r\\n    end\\r\\n    a = r.score\\r\\n    if ( stage == 1 ) then -- [s + ws ] + w + s\\r\\n        mode = \\\"s + ws + w + s\\\"\\r\\n        r = _sh ( r )\\r\\n        do_global_wiggle_sidechains ( 1 )\\r\\n    elseif ( stage == 2 ) then -- [ws + s] + w + s    \\r\\n        mode = \\\"ws + s + w + s\\\"\\r\\n        r = _ws ( r )\\r\\n        do_shake ( 1 )\\r\\n    elseif ( stage == 3 ) then -- [ws] + w + s\\r\\n        mode = \\\"ws + w + s\\\"\\r\\n        r = _ws ( r )\\r\\n        if puzzle.score () < 0 then do_shake ( 1 ) end\\r\\n    elseif ( stage == 4 ) then -- [s] + w + s\\r\\n        mode = \\\"s + w + s\\\"\\r\\n        r = _sh ( r )\\r\\n    elseif ( stage == 5 ) then -- [wb] + s    \\r\\n        mode = \\\"wb + s\\\"\\r\\n        puzzle.wiggle_backbone ( 1 )\\r\\n    elseif ( stage == 6 ) then -- [w] + s\\r\\n        mode = \\\"w\\\"\\n    end -- nop:w\\r\\n    --if ( stage ~= 5 ) then    \\r\\n        puzzle.wiggle_all ( 1 )\\r\\n    --end\\r\\n    if ( stage ~= 6 ) then\\r\\n\\t\\tstabilize.do_shake_end ( 1 )\\r\\n    end    \\r\\n    restore_recent_best ()\\r\\n    b = puzzle.score ()\\r\\n    if b > a then\\r\\n\\t--hash.empty ()\\r\\n        r.score = b\\r\\n        r.mode = mode\\r\\n        puzzle.checkScore ( a\\\,r )    \\r\\n    end    \\r\\n    return r\\r\\nend\\r\\n\\r\\nfunction qs_fuse.smartFuse ( n\\\,k )\\r\\n    local b\\r\\n    local r\\r\\n    local gain\\r\\n    gain = 1e6\\r\\n    r = {\\r\\n        b_firstTime = true\\\,\\r\\n        score = 0\\\,\\r\\n        mode = \\\"w\\\"\\\,\\r\\n\\t\\tsbs = 0\\\, -- score before shake\\r\\n\\t\\tws_slot = ws_slot\\\,\\r\\n\\t\\tsh_slot = sh_slot\\\,\\r\\n\\t\\tws_skip = false\\\,\\r\\n\\t\\tsh_skip =  false\\\,\\r\\n    }\\r\\n    while ( gain > 0.001 ) do\\r\\n        local a\\r\\n        a = puzzle.score ()\\r\\n        puzzle.ci ( n )        \\r\\n        puzzle.do_shake ( 1 )            \\r\\n        puzzle.ci ( 1 )   \\r\\n        r.score = a\\r\\n        r = stabilize.try_stage ( 1\\\,r )\\r\\n        r = stabilize.try_stage ( 2\\\,r )\\r\\n        r = stabilize.try_stage ( 3\\\,r )\\r\\n        r = stabilize.try_stage ( 4\\\,r )\\r\\n        r = stabilize.try_stage ( 5\\\,r )\\r\\n        r = stabilize.try_stage ( 6\\\,r )\\r\\n        b = puzzle.score ()\\r\\n        gain = b - a\\r\\n        k = b--k = puzzle.checkScore ( k\\\,r )\\r\\n    end\\r\\n    return k\\r\\nend\\r\\n\\r\\nfunction qs_fuse.smartFuse2 ( n\\\,k )\\r\\n    local b\\r\\n    local r\\r\\n    local gain\\r\\n    gain = 1e6\\r\\n    r = {\\r\\n        b_firstTime = true\\\,        \\r\\n        score = 0\\\,\\r\\n        mode = \\\"w\\\"\\\,\\r\\n\\t\\tsbs = 0\\\, -- score before shake\\r\\n\\t\\tws_slot = ws_slot\\\,\\r\\n\\t\\tsh_slot = sh_slot\\\,\\r\\n\\t\\tws_skip = false\\\,\\r\\n\\t\\tsh_skip =  false\\\,\\r\\n    }\\r\\n    while ( gain > 0.001 ) do\\r\\n        local a\\r\\n        a = puzzle.score ()\\r\\n        puzzle.ci ( n )        \\r\\n        puzzle.wiggle_backbone ( 1 )--all ( 1 )\\r\\n        puzzle.ci ( 1 )   \\r\\n        r.score = a\\r\\n        r = stabilize.try_stage ( 1\\\,r )\\r\\n        r = stabilize.try_stage ( 2\\\,r )\\r\\n        r = stabilize.try_stage ( 3\\\,r )\\r\\n        r = stabilize.try_stage ( 4\\\,r )\\r\\n        r = stabilize.try_stage ( 5\\\,r )\\r\\n        r = stabilize.try_stage ( 6\\\,r )\\r\\n        b = puzzle.score ()\\r\\n        gain = b - a\\r\\n        k = b--k = puzzle.checkScore ( k\\\,r )\\r\\n    end\\r\\n    return k\\r\\nend\\r\\n\\nreset_recent_best ()\\n\\r\\nselect_all ()\\n\\r\\nk = puzzle.score ()\\n  \\r\\nprint ( \\\"QS - BlueFuse..\\\" )\\r\\nprint ( \\\"Starting score = \\\"\\\, k )\\r\\n\\nwhile ( 1 ) do     \\r\\n    print ( \\\"Step_0.05\\\" )   \\r\\n    k = qs_fuse.smartFuse ( 0.05\\\,k )\\r\\n    k = qs_fuse.smartFuse2 ( 0.05\\\,k ) \\r\\n    print ( \\\"Step_0.07\\\" )\\r\\n    k = qs_fuse.smartFuse ( 0.07\\\,k )\\r\\n    print ( \\\"Step_0.65\\\" )\\r\\n    k = qs_fuse.smartFuse2 ( 0.65\\\,k )  \\r\\nend -- while ( 1 )\\r\\n\"\n \"script_version\" : \"1\"\n \"share_scope\" : \"-456610413\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_143676149" : "{\n \"desc\" : \"GA bands w allowed loss\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"GAB Loss 0.7 -- SG\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"0\"\n \"script\" : \"--[[\\nGAB -Genetic Algorithm on Bands\\nby Rav3n_pl\\nbased on CartoonVillan and Crashguard303 scripts\\n\\nDefinitions:\\nband: randomised: start segment\\\, end segment\\\, length\\\, strength\\ncritter: set of bands\\nherd: set of critters\\n\\n1.\\n- randomize needed bands \\n- randomly assignig them to criters\\n\\n2.\\n- score each critter\\n\\n3.\\n- keep critters scoring above score\\n- breed best critters\\n- breed bastards (best one + random one)\\n- forget about rest of critter\\n- randomize new critters to fill herd\\n\\n]]--\\n\\nlocal g_randomSeed = -1\\nlocal STATUS = { OK = 0\\\, CONTINUE = 1\\\, CANCEL = 2 }\\n\\nlocal dlg = dialog.CreateDialog('Anthropic Dreams - GAB Loss Recipe')\\ndlg.lbl_00 = dialog.AddLabel('')\\ndlg.lbl_01 = dialog.AddLabel('Enter Seed')\\ndlg.input = dialog.AddTextbox('(optional) '\\\,'')\\ndlg.lbl_02 = dialog.AddLabel('')\\ndlg.btn = dialog.AddButton('continue'\\\,1)\\nif dialog.Show(dlg) == STATUS.CONTINUE then\\n    if dlg.input.value and dlg.input.value ~= '' then\\n        g_randomSeed = math.abs(dlg.input.value*1) -- char2int --\\n    end\\nend\\n\\n-- options:\\nenergy=false --set true to seek energy in exploration puzzles; false works on all puzzles\\npullCI=0.9 --Clash Impotrance during pull\\nfastQstab=true--true -- only 1ong SH 1ong WA after pull if true\\nfuzeThresh = 1 -- run fuze if we are close to best score (negative=new best score)\\nqstabThresh=30--10 -- run qstab if score drops more than... wiggle only in other case\\nmaxCI=1 --changle to lower if not want tu use c=1 shake/wiggle at all. good in eraly game\\n\\nherd= --herd options\\n{ \\nbreedBest = 5\\\, --breed best 4 critters - all combinations => 6 kids form 4 critters\\\, 3 form 3\\\, 1 form 2\\\, 9 form 5 ;]\\nkeepBest = 3\\\, --save up to 3 best scoring critters\\\, rest are forgotten\\nbreedBastards = 8\\\, --number of best will have one random bastard\\nnewRandom = 10\\\, --adding new random ones each generation\\nmaxGen= 25\\\, --maximum generations \\nshuffle = true\\\, --set true to run critters in random order\\nrenew=4\\\, --create totally fresh herd after that many gens w/o improvement\\n}\\ncritter= --critter options\\n{\\nminBands=1\\\, --minimum bands\\nmaxBands=4\\\,--7\\\, --maximum bands\\nkeepScore = 0.1 \\\, --survive to next gen only if score higher than\\nbreedScore=-20\\\, --will breed kids only if score higher. Basttards always breed\\nmaxLoss=30\\\, --maximum loss by critter. set 0 to disable\\n}\\n\\nbands= --bands options\\n{\\nminStr=0.3\\\, --minimum band str\\nmaxStr=1.5\\\, --maximum band str\\nminChng = 3\\\, -- minimum change of band len accordig to current distance\\nmaxUp = 7.1\\\, -- maximum change up (push)\\nmaxDn = 7.9\\\, -- maximum change down (pull)\\nminSkip = 10\\\, --minimum segment distance\\nminDist = 4\\\, --minimum spatial distance\\nminLen = 2\\\, --minimum lenght of created band\\n}\\n\\nDoNotUse={--just comment lines below or add more areas to avoid\\n--{segCnt\\\,segCnt}\\\, --ligand cant be used\\n--{120\\\,134}\\\,\\n--{1\\\,10}\\\,\\n}\\nAlwaysUse={ --areas should be always used\\n--{segCnt\\\,segCnt}\\\,--ligand need to be at one end\\n--{308\\\,311}\\\, --loopy\\n--{272\\\,319}\\\, --loopy\\n}\\n\\n-- bands by secondary structure\\nuse=\\n{\\nSheet=true\\\, --set false to not band sheets\\nHelix=true\\\, --set false to not band helices\\nLoop=true\\\, --set false to not band loops\\n}\\ncheckBoth=false --check both ends to above\\\, if false only one end need to be true\\n\\n--end of options\\n\\nsegCnt=structure.GetCount()\\np=print\\nfunction CI(c)\\nif c>maxCI then c=maxCI end\\nbehavior.SetClashImportance(c)\\nend\\nfunction round(x)--cut all afer 3-rd place\\n    return x-x%0.001\\nend\\nfunction down(x)\\n    return x-x%1\\nend\\nfunction Score()--return score\\\, exploration too\\n    if energy==true then\\n        return current.GetScore()\\n    else\\n        return current.GetEnergyScore()\\n    end\\nend \\nfunction SmartWiggle(how\\\,iters\\\,minppi)\\n  local _minppi_ = minppi\\n  local _iters__ = iters\\n  if _minppi_ == nil then _minppi_ = 1 end\\n  if _iters_ == nil then _iters_ = 1 end\\n  function wa(i\\\,bb\\\,sc\\\,minpts)\\n    local gain_found = true\\n    while (gain_found) do\\n      local s_0 = current.GetScore()\\n      structure.WiggleAll(i\\\,bb\\\,sc)\\n      gain_found = current.GetScore() > s_0+minpts\\n    end\\n  end\\n  if how == \\\"wb\\\" then wa(_iters_\\\,true\\\,false\\\,_minppi_)\\n  elseif how == \\\"ws\\\" then wa(_iters_\\\,false\\\,true\\\,_minppi_)\\n  else wa(_iters_\\\,true\\\,true\\\,_minppi_) \\n  end\\nend\\nfunction Wiggle(how\\\, iters\\\, minppi)\\n    if how==nil then how=\\\"wa\\\" end\\n    if iters==nil then iters=6 end\\n    if minppi==nil then minppi=0.1 end\\n    if iters>0 then\\n        iters=iters-1\\n        sp=Score()\\n        if how == \\\"s\\\" then structure.ShakeSidechainsAll(1)\\n            elseif how == \\\"wb\\\" then structure.WiggleAll(2\\\,true\\\,false)\\n            elseif how == \\\"ws\\\" then structure.WiggleAll(2\\\,false\\\,true)\\n            elseif how == \\\"wa\\\" then structure.WiggleAll(2) \\n        end\\n        ep = Score()\\n        ig=ep-sp\\n        if how~=\\\"s\\\" then\\n            if ig > minppi then return Wiggle(how\\\, iters\\\, minppi) end --tail call\\n        end\\n    end\\nend\\n\\n--[[\\nTlaloc`s math library\\n------------------------------------------------------------------------\\nThe original random script this was ported from has the following notices:\\nCopyright (c) 2007 Richard L. Mueller\\nHilltop Lab web site - http://www.rlmueller.net\\nVersion 1.0 - January 2\\\, 2007\\nYou have a royalty-free right to use\\\, modify\\\, reproduce\\\, and\\ndistribute this script file in any way you find useful\\\, provided that\\nyou agree that the copyright owner above has no warranty\\\, obligations\\\,\\nor liability for such use.\\n------------------------------------------------------------------------\\n]]--\\nlocal lngX = 1000\\nlocal lngC = 48313\\nlocal function _random(m\\\,n)\\n    local A_Hi = 63551\\n    local A_Lo = 25354\\n    local M = 4294967296\\n    local H = 65536\\n    \\n    function _MWC()\\n        local S_Hi = math.floor(lngX / H)\\n        local S_Lo = lngX - (S_Hi * H)\\n        local C_Hi = math.floor(lngC / H)\\n        local F1 = A_Hi * S_Hi\\n        local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi\\n     \\n        lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)\\n        lngX = lngX - (math.floor(lngX / M) * M)\\n        lngC = math.floor((F2 / H) + F1)\\n\\n        return lngX\\n    end\\n    \\n    if n == nil and m ~= nil then\\n        n = m\\n        m = 1\\n    end\\n    if (m == nil) and (n == nil) then\\n        return _MWC() / M\\n    else\\n        if n < m then\\n            return nil\\n        end\\n        return math.floor((_MWC() / M) * (n - m + 1)) + m\\n    end\\nend\\nlocal function _abs(value)\\n    if value < 0 then\\n        return -value\\n    else\\n        return value\\n    end\\nend\\nlocal function _floor(value)\\n    return value - (value % 1)\\nend\\nlocal function _randomseed(s)\\n    local f = recipe.GetRandomSeed\\n    if g_randomSeed > 0 then\\n        s = g_randomSeed\\n    elseif s==nil then \\n        s=math.abs(f())--math.abs(Score())\\n        while s==0 do s=math.abs(f()) end\\n        --s=s%0.001\\n        --s=1/s\\n        while s<100000 do s=s*1000 end\\n        s=s-s%1\\n        g_randomSeed = s\\n    end\\n    lngX = s\\n    p(\\\"Random seed is \\\"..s)\\nend\\n\\nmath=\\n{\\n    abs = _abs\\\,\\n    floor = _floor\\\,\\n    random = _random\\\,\\n    randomseed = _randomseed\\\,\\n}\\nmath.randomseed()\\n--[[ End math library ]]--\\n\\nfunction SaveBest()\\n    local g=Score()-bestScore\\n    if g>0 then\\n        if g>0.01 then p(round(Score())\\\,\\\"Gained another \\\"\\\,round(g)\\\,\\\" pts.\\\") end\\n        bestScore=Score()\\n        save.Quicksave(3)\\n    end\\nend\\nfunction SaveRB()\\n    save.Quicksave(4)\\n    recentbest.Restore()\\n    SaveBest()\\n    save.Quickload(4)\\nend\\nfunction Qstab()\\n    selection.SelectAll()\\n    CI(pullCI)--(0.1)\\n    local s_0 = Score()\\n    Wiggle(\\\"s\\\"\\\,1)\\n    if Score()-s_0 < 0.001 then\\n        Wiggle(\\\"ws\\\"\\\,1)\\n    end\\n    if fastQstab==false then \\n        CI(0.4)\\n        Wiggle(\\\"wa\\\"\\\,1)\\n        CI(1)\\n        Wiggle(\\\"s\\\"\\\,1)\\n    end\\n    CI(1)\\n    Wiggle()\\nend\\nfunction FuzeEnd()\\n    CI(1)\\n    SmartWiggle(\\\"wa\\\"\\\,1\\\,1)--Wiggle(\\\"wa\\\"\\\,1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    SmartWiggle(\\\"wa\\\"\\\,1\\\,1)--Wiggle()\\n    srb()\\nend\\nfunction Fuze1(ci1\\\,ci2)\\n    CI(ci1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\nend\\nfunction Fuze2(ci1\\\,ci2)\\n    CI(ci1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(1)\\n    SmartWiggle(\\\"wa\\\"\\\,1\\\,1)--Wiggle(\\\"wa\\\"\\\,1)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\nend\\nfunction srb()\\n    recentbest.Restore()\\n    SaveBest()\\nend\\nfunction Fuze()\\n    p(\\\"Fuzing...\\\")\\n    local scr=Score()\\n    selection.SelectAll()\\n    recentbest.Save()\\n    Fuze1(0.3\\\,0.6) FuzeEnd()\\n    Fuze2(0.3\\\,1) srb()\\n    Fuze1(0.05\\\,1) srb()\\n    Fuze2(0.7\\\,0.5) FuzeEnd()\\n    Fuze1(0.07\\\,1)\\n    srb()\\nend\\n\\nfunction random(n1\\\,n2) --random function returns int or float depends on input vars\\n    if n2==nil and n1==nil then\\n        return math.random() --float\\n    else\\n        if n2==nil then\\n            if n1%1==0 then\\n                return math.random(n1) --integer\\n            else\\n                return math.random()*n1 --float\\n            end\\n        else\\n            if n1%1==0 and n2%1==0 then\\n                return math.random(n1\\\,n2) --integer between \\n            else\\n                return math.random()*(n2-n1)+n1 --float between\\n            end\\n        end\\n    end\\nend\\n\\nfunction FillHerd() --fill up herd\\n    local n=\\\#critters\\n    if n>0 then --fill up\\n        n=herd.newRandom\\n    else --fresh herd\\n        n=herd.breedBest + herd.keepBest + herd.breedBastards \\n    end\\n    p(\\\"Randomizing \\\"..n..\\\" new critters...\\\")\\n    for i=1\\\,n do\\n        AddCritter()\\n    end\\nend\\nfunction AddCritter() --vreate new random critter\\n    local c={}\\n    critterID=critterID+1\\n    c.no=critterID\\n    c.name=c.no..'-rnd'\\n    c.bands={}\\n    local r=random(critter.minBands\\\, critter.maxBands)\\n    for i=1\\\,r do\\n        c.bands[\\\#c.bands+1]=AddBand()\\n    end\\n    critters[\\\#critters+1]=c\\n    p(c.name..\\\" bands: \\\"..\\\#c.bands)\\nend\\nfunction AddBand() --create one random band\\n    local cnt=0\\n    local b={}\\n    while true do --try till die\\n        cnt=cnt+1\\n        local s1=random(segCnt)\\n        local s2=random(segCnt)\\n        if s1>s2 then s1\\\,s2=s2\\\,s1 end --swap\\n        if CanBeUsed(s1\\\,s2) then\\n            local str=random(bands.minStr\\\,bands.maxStr)\\n            local len=0\\n            while true do --randomize corect distance\\n                len=random(-bands.maxDn\\\,bands.maxUp)\\n                if len<-bands.minChng or len>bands.minChng then break end\\n            end\\n            b={s1\\\,s2\\\,str\\\,len}\\n            break\\n        end\\n        if cnt>100 then\\n            p(\\\"Sorry! Cant create band! Breaking script!\\\")\\n            BreakScript() --there is no such function\\\, so it crashes script\\n        end\\n    end\\n    return b\\nend\\n\\nfunction CanBeUsed(sg1\\\,sg2) --checking end of bands\\n    function ssCheck(ss)\\n        local good=false\\n            if use.Sheet and ss==\\\"E\\\" then good=true end\\n            if use.Helix and ss==\\\"H\\\" then good=true end\\n            if use.Loop and ss==\\\"L\\\"  then good=true end\\n        return good\\n    end\\n    function AreGood(s1\\\,s2) --check that s1 and s2 can be used\\n      local ok=true\\n      if s2-s1<bands.minSkip then ok=false end\\n      if ok==true and structure.GetDistance(s1\\\,s2)<bands.minDist then ok=false end\\n      return ok \\n    end\\n    local ok=AreGood(sg1\\\,sg2)\\n    if ok==true and \\\#DoNotUse>0 then --none of 2 can be in that area\\n        for i=1\\\, \\\#DoNotUse do\\n            local r=DoNotUse[i]\\n            for x=r[1]\\\,r[2] do\\n                if x==sg1 or x==sg2 then\\n                    ok=false\\n                    break\\n                end\\n            end\\n            if ok==false then break end\\n        end\\n    end\\n    if ok==false then \\n        return false --if false can`t be used\\n    else\\n        ok=false\\n        if \\\#AlwaysUse>0 then --at least one have to be there\\n            for i=1\\\, \\\#AlwaysUse do\\n                local r=AlwaysUse[i]\\n                for x=r[1]\\\,r[2] do\\n                    if x==sg1 or x==sg2 then\\n                        ok=true\\n                        break\\n                    end\\n                end\\n                if ok==true then break end\\n            end\\n        else\\n            ok=true\\n        end\\n    end \\n    if ok==true then --check structure\\n        ok=false\\n        local ss1=structure.GetSecondaryStructure(sg1)\\n        local ss2=structure.GetSecondaryStructure(sg2)\\n        if checkBoth then\\n            if ssCheck(ss1) and ssCheck(ss2) then ok=true end\\n        else\\n            if ssCheck(ss1) or ssCheck(ss2) then ok=true end\\n        end\\n    end\\n    return ok\\nend\\n\\nfunction ScoreHerd() --score all critters from herd\\n    --save.Quickload(3)\\n    p(\\\"Seed \\\"..g_randomSeed)\\n    p(\\\"Scoring \\\"..\\\#critters..\\\" critters...\\\")\\n    --save.Quicksave(5)\\n    local herdScore=Score()\\n    for i=1\\\,\\\#critters do\\n        band.DeleteAll()\\n        local crt=critters[i] --critter\\n        local s=Score() --start score\\n        local bnds=crt.bands\\n        for b=1\\\,\\\#bnds do\\n            local bnd=bnds[b]\\n            band.AddBetweenSegments(bnd[1]\\\,bnd[2])\\n            local bc=band.GetCount()\\n            band.SetStrength(bc\\\,bnd[3])\\n            local len=structure.GetDistance(bnd[1]\\\,bnd[2])+bnd[4]\\n            if len<bands.minLen then len=bands.minLen end\\n            band.SetGoalLength(bc\\\,len)\\n        end\\n        selection.SelectAll()\\n        CI(pullCI)\\n        recentbest.Save()\\n        Wiggle(\\\"wb\\\"\\\,1)\\n        band.DeleteAll()\\n        Wiggle(\\\"s\\\"\\\,1)\\n        ui.CenterViewport()\\n        CI(1)\\n        Wiggle(\\\"wa\\\"\\\,1)\\n        if s-Score() > qstabThresh then\\n            Qstab()\\n        else\\n            Wiggle()\\n        end\\n        if Score()-bestScore>fuzeThresh then \\n            SaveRB()\\n            Fuze() \\n        else\\n            SaveRB()\\n        end\\n        crt.score=Score()-s\\n        p(\\\"Critter \\\"..crt.name..\\\" : \\\"..round(crt.score))\\n        if critter.maxLoss>0 then\\n            if Score()>herdScore-critter.maxLoss then\\n                save.Quicksave(5)\\n                herdScore=Score()\\n            else\\n                save.Quickload(5)\\n                recentbest.Save()\\n            end\\n        else\\n           save.Quickload(3)\\n        end\\n    end\\n    save.Quickload(3)\\n    if band.GetCount() then --clean bands from best solition (if any)\\n        band.DeleteAll()\\n        save.Quicksave(3)\\n    end\\nend\\nfunction BreedCritters(mom\\\,dad\\\,t) --breed 2 critters. bands are taken randomly\\n    local kid={}\\n    critterID=critterID+1\\n    kid.no=critterID\\n    kid.name=kid.no..\\\"-\\\"..t..mom.no..'/'..dad.no\\n    kid.bands={}\\n local mb=\\\#mom.bands\\n local db=\\\#dad.bands\\n if mb>db then mb\\\,db=db\\\,mb end --kid have bands count between mom and dad bands\\n    local bn=random(mb\\\,db)\\n    for i=1\\\,bn\\\,2 do\\n        kid.bands[\\\#kid.bands+1]=mom.bands[random(\\\#mom.bands)]\\n        kid.bands[\\\#kid.bands+1]=dad.bands[random(\\\#dad.bands)]\\n    end\\n    p(kid.name..\\\" bands: \\\"..\\\#kid.bands)\\n    return kid\\nend\\nfunction KeepGood() --copy best scoring critters form last gen if score above\\n    local newHerd={}\\n    for i=1\\\,herd.keepBest do\\n        if critters[i].score>critter.keepScore  and (math.abs(critters[i].score)>0.1 or critters[i].score>0) then\\n            newHerd[\\\#newHerd+1]=critters[i]\\n        end\\n    end\\n    return newHerd\\nend\\nfunction SortCritters() --bubble sort\\n    for i=1\\\,\\\#critters do\\n        for j=i+1\\\,\\\#critters do\\n            if critters[i].score<critters[j].score then\\n                critters[i]\\\,critters[j]=critters[j]\\\,critters[i] --love lua :)\\n            end\\n        end\\n    end\\nend\\nfunction BreedHerd()\\n    p(\\\"Breeding...\\\")\\n    SortCritters()\\n    newHerd=KeepGood()\\n    for i=1\\\, herd.breedBest do\\n        local mom=critters[i]\\n        if mom.score>critter.breedScore or i<2 then --breed only good ones\\\, 1st is always breed anyway\\n            for j=i+1\\\, herd.breedBest do\\n                local dad=critters[j]\\n                newHerd[\\\#newHerd+1]=BreedCritters(mom\\\,dad\\\,\\\"kid-\\\")\\n                newHerd[\\\#newHerd+1]=BreedCritters(dad\\\,mom\\\,\\\"kid-\\\")\\n            end\\n        end\\n    end\\n    for i=1\\\, herd.breedBastards do --they will always appear ;]\\n        local mom=critters[i]\\n        local j=random(herd.breedBastards+1\\\,\\\#critters)\\n        local dad=critters[j]\\n        newHerd[\\\#newHerd+1]=BreedCritters(mom\\\,dad\\\,\\\"bastard-\\\")\\n        newHerd[\\\#newHerd+1]=BreedCritters(dad\\\,mom\\\,\\\"bastard-\\\")\\n    end\\n    critters=newHerd\\n    FillHerd()\\nend\\nfunction ShuffleHerd()\\n    if herd.shuffle==true then \\n        for i=1\\\,\\\#critters do\\n            local r=random(\\\#critters)\\n            if r~=i then\\n                critters[i]\\\,critters[r]=critters[r]\\\,critters[i]\\n            end\\n        end\\n    end\\nend\\nfunction GAB()\\n    bestScore=Score()\\n    critterID=0\\n    gen=0\\n    ss=Score()\\n    save.Quicksave(3)\\n    recentbest.Save()\\n    p(\\\"Starting Rav3n_pl GAB v0.6.2 -SG recipe\\\\nStart score: \\\"..round(ss))\\n    critters={}\\n    FillHerd()\\n    badGen=0\\n    while true do --this is (almost) endless script ;]\\n        genScore=Score()\\n        gen=gen+1\\n        p()\\n        p(\\\"Generation: \\\"..gen..\\\"\\\, score: \\\"..round(Score())..\\\"\\\, gain: \\\"..round(Score()-ss))\\n        ShuffleHerd()\\n        ScoreHerd()\\n        save.Quickload(3)\\n        if gen==herd.maxGen then break end --end of script\\n        if genScore>=Score() then badGen=badGen+1 else badGen=0 end\\n        if badGen>=herd.renew then \\n            p(\\\"Creating fresh random herd...\\\")\\n            critters={}\\n            FillHerd()\\n            badGen=0\\n        else\\n            BreedHerd()\\n        end\\n    end\\n    p(\\\"Final score: \\\"..round(Score())..\\\" Total gain: \\\"..round(Score()-ss))\\nend\\n\\n-- main call\\nxpcall(GAB\\\,absolutebest.Restore)\\n\\n--end of script\\n\\n\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"94208\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1505672353" : "{\n \"desc\" : \"Testing for best scoring segments then LWS them and buddies.   Take all points it founds in pyramid.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"1\"\n \"mid\" : \"27270\"\n \"mrid\" : \"37193\"\n \"name\" : \"Lucky LWS v2.5 endgame\"\n \"parent\" : \"4401\"\n \"parent_mrid\" : \"30537\"\n \"player_id\" : \"174969\"\n \"script\" : \"--[[\\n    Lucky LWS\\n    serach and LWS best scoring segments\\n    options at end\\n]]--\\n\\np=print\\nsegCnt=get_segment_count()\\nfunction Score()\\n    return get_score(true)\\nend\\nfunction round(x)--cut all afer 3-rd place\\n    return x-x%0.001\\nend\\n\\nfunction getpoints()\\n    t={}\\n    p(\\\"Searching best scoring segments.\\\")\\n    local ss=Score()\\n    deselect_all()\\n    do_unfreeze_all()\\n    for i=startS\\\, endS do --fill score table\\n        quicksave(4)\\n        deselect_all()\\n        select_index(i)\\n        local scs=Score()\\n        do_local_wiggle(1)\\n        local g=Score()-scs\\n        t[\\\#t+1]={i\\\,g}\\n        p(\\\"Segment \\\"\\\,i\\\,\\\" score: \\\"\\\,g)\\n        if g<keepTest then quickload(4) end\\n    end\\n    p(\\\"Test score gain: \\\"\\\,round(Score()-ss))\\n    return t\\nend\\n\\nfunction wig(mingain)    --score conditioned wiggle\\\,\\n    repeat                    --wiggles selected segments\\n        local ss=Score()\\n        do_local_wiggle(2)\\n        local wg=Score()-ss\\n        if wg<0 then\\n            restore_recent_best()\\n        end\\n    until wg<mingain\\n    deselect_all()\\nend\\n\\n\\nfunction wiggle(s\\\, mingain\\\, buddies)\\n    p(\\\"Wigglin segment \\\"\\\,s)\\n    deselect_all()\\n    local sgs=Score()\\n    select_index(s)\\n    wig(mingain)\\n    if buddies > 0 then --select buddies\\n        for b=1\\\, buddies do\\n            deselect_all()\\n            if s+b>endS then select_index_range(s\\\,endS)\\n            else select_index_range(s\\\,s+b)end\\n            wig(mingain)\\n        \\n            if s-b<startS then select_index_range(startS\\\,s)\\n            else select_index_range(s-b\\\,s)end\\n            wig(mingain)\\n\\n            if s+b>endS then select_index_range(s\\\,endS)\\n            else select_index_range(s\\\,s+b)end\\n            if s-b<startS then select_index_range(startS\\\,s)\\n            else select_index_range(s-b\\\,s)end\\n            wig(mingain)\\n        end\\n    end\\n    p(\\\"Segment gain: \\\"\\\,round(Score()-sgs))\\nend\\nfunction AllLoop() --turning entire structure to loops\\n    local ok=false\\n    for i=1\\\, segCnt do\\n        local s=get_ss(i)\\n        if s~=\\\"L\\\" then \\n            save_structure()\\n            ok=true\\n            break\\n        end\\n    end\\n    if ok then\\n        select_all()\\n        replace_ss(\\\"L\\\")\\n    end\\nend\\nfunction Sort(tab\\\,items) -- bubble sorting - lowest on top\\\, only needed items\\n    if items>\\\#tab then items=\\\#tab end\\n    for x=1\\\,items do --items do\\n        for y=x+1\\\,\\\#tab do\\n            if tab[x][2]<tab[y][2] then\\n                tab[x]\\\,tab[y]=tab[y]\\\,tab[x]\\n            end\\n        end\\n    end\\n    return tab\\nend\\nfunction LuckyLWS()\\n    if endS==nil then endS=segCnt end\\n    set_behavior_clash_importance(1)\\n    do_unfreeze_all()\\n    AllLoop()\\n    reset_recent_best()\\n    sscore=Score()\\n    besttable=getpoints()\\n    besttable=Sort(besttable\\\,howmany)\\n    if howmany>\\\#besttable then howmany=\\\#besttable end\\n    for i=1\\\, howmany do\\n        if besttable[i][2]>=LWSonly then\\n            local seg=besttable[i][1]\\n            reset_recent_best()\\n            wiggle(seg\\\, mingain\\\, buddies)\\n        end\\n    end\\n    p(\\\"Total gain: \\\"\\\, round(Score()-sscore))\\n    load_structure()\\nend\\n\\nkeepTest = 0 --keep test points only when gain is more than\\nLWSonly = 0 --do lws only if test more than\\nhowmany = 10  --how many best\\nmingain = 0.1 --minimum gain per wiggle iterations\\nbuddies = 4 -- how many segments aside should be wiggled too\\n\\nstartS=1\\nendS=nil\\n\\nfor i=1\\\,3 do --run 3 times\\n    LuckyLWS()\\nmingain=mingain/10\\nend\\n\\n\\n\"\n \"script_version\" : \"1\"\n \"share_scope\" : \"1970237984\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1518849457" : "{\n \"desc\" : \"LWS on segments by stride\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"LWS-SG\"\n \"parent\" : \"101700\"\n \"parent_mrid\" : \"202316\"\n \"player_id\" : \"0\"\n \"script\" : \"-- LWS-SG\\nlocal stride = 2\\nlocal boost = 2\\nlocal k = structure.GetCount()-stride\\nlocal segs = structure.GetCount()\\nlocal s0 = current.GetScore()\\nlocal s1 = current.GetScore()\\nlocal maxstride = segs\\nlocal iters = 1\\nlocal start = 1\\nlocal thresh = 0.001\\nlocal gain = true\\nprint('LWS-SG script\\\\nSegments: '..k..'\\\\n')\\nrecentbest.Save()\\nwhile(stride<maxstride and gain) do\\nprint('Stride: '..stride..'\\\\nScore: '..s0)\\nlocal s_1 = s0\\nselection.DeselectAll()\\nselection.SelectRange(1\\\,1+stride)\\nfor i=start\\\,k do\\n  if i-1>0 then\\n    selection.Deselect(i-1)\\n  end\\n  selection.Select((i+stride) or segs)\\n  local gain_found = true\\n  while(gain_found) do\\n    local s_0 = current.GetScore()\\n    structure.LocalWiggleSelected(iters)\\n    gain_found = current.GetScore()>s_0+1\\n  end\\n  recentbest.Restore()\\n  s1 = current.GetScore()\\n  if (s1-s0)>thresh then\\n    print('Gain found: '..s1\\\,' +'..(s1-s0)..'\\\\n')\\n    s0 = s1\\n  end\\nend\\ngain = current.GetScore()-s_1>1\\nstride = stride + boost\\nk = segs - stride\\nend\\n\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"3\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1581476208" : "{\n \"desc\" : \"Structure prediction recipe\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"101705\"\n \"mrid\" : \"202321\"\n \"name\" : \"STRUCT_PREDICT-SG\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"199249\"\n \"script\" : \"-- STRUCTURE_PREDICTOR-SG --\\nlocal queue = structure.GetCount()\\nfunction assign_seg(a\\\,s\\\,o)\\n  selection.Select(a)\\n  structure.SetSecondaryStructureSelected(s)\\n  selection.DeselectAll()\\n  o[a] = true\\n  queue = queue-1\\n  return o\\nend\\nfunction assign_pair(a\\\,b\\\,s\\\,o)\\n  selection.Select(a)\\n  selection.Select(b)\\n  structure.SetSecondaryStructureSelected(s)\\n  selection.DeselectAll()\\n  o[a] = true\\n  o[b] = true\\n  queue = queue-2\\n  return o\\nend\\nfunction _main_()\\n  local k = structure.GetCount()\\n  local E_dist = 4.5 -- iff 7+ segments away\\n  local H_dist = 5.5 -- iff 3+ segments away\\n  local M_dist = 0.0 -- mutables\\n  local variance = 0.49\\n  local isassigned = {}\\n  print('Structure-Predictor SG recipe\\\\nWorking..\\\\n')\\n  save.SaveSecondaryStructure()\\n  selection.SelectAll()\\n  structure.SetSecondaryStructureSelected('l')\\n  selection.DeselectAll()\\n  for i=1\\\,k do\\n    for j=2\\\,k do\\n      local dist = structure.GetDistance(i\\\,j)\\n      local E_seg_test = math.abs(i-j)>6\\n      local H_seg_test = math.abs(i-j)>2\\n      local E_dist_test = (E_dist+variance>=dist) and (E_dist-variance<=dist)\\n      local H_dist_test = (H_dist+variance>=dist) and (H_dist-variance<=dist)\\n      local i_assigned = isassigned[i]==nil\\n      local j_assigned = isassigned[j]==nil\\n\\n--[[ --DEBUG--\\nprint('segments'\\\,i\\\,j)\\nprint('dist'\\\,dist)\\nprint('E_seg_test'\\\,E_seg_test)\\nprint('H_seg_test'\\\,H_seg_test)\\nprint('E_dist_test'\\\,E_dist_test)\\nprint('H_dist_test'\\\,H_dist_test)\\nprint('i_assigned'\\\,i_assigned)\\nprint('j_assigned'\\\,j_assigned)\\nprint('')\\n]]--\\n\\n      local ss = 'l'\\n      if i_assigned==false and j_assigned==false then\\n        if E_seg_test then\\n          ss = 'e'\\n        elseif H_seg_test then\\n          ss = 'h'\\n        end\\n        isassigned = assign_pair(i\\\,j\\\,ss\\\,isassigned)   \\n      elseif i_assigned then\\n        if E_seg_test then\\n          ss = 'e'\\n        elseif H_seg_test then\\n          ss = 'h'\\n        end\\n        isassigned = assign_seg(j\\\,ss\\\,isassigned)\\n      elseif j_assigned then\\n        if E_seg_test then\\n          ss = 'e'\\n        elseif H_seg_test then\\n          ss = 'h'\\n        end\\n        isassigned = assign_seg(i\\\,ss\\\,isassigned)\\n      end -- test\\n      if queue<1 then\\n        return\\n      end\\n    end -- loopf\\n  end -- loopf\\nend\\n\\nxpcall(_main_\\\,absolutebest.Restore)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1653393927" : "{\n \"desc\" : \"LWS on segments by stride (RAINBOW)\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"RAIN-LWS-SG\"\n \"parent\" : \"101700\"\n \"parent_mrid\" : \"202316\"\n \"player_id\" : \"0\"\n \"script\" : \"-- LWS-SG\\nfunction selection.Highlight(d\\\,k\\\,start\\\,stride\\\,stride_gap)\\n  local next_i = 0\\n  if d=='up' then\\n    next_i = 1+stride+stride_gap\\n    for i=start\\\,k do\\n      if i+stride_gap<next_i or i==k then\\n        selection.Select(i)\\n      else\\n         next_i = i+stride+stride_gap\\n      end\\n    end\\n  else--d=='down'\\n    next_i = k-stride-stride_gap\\n    for i=k\\\,start\\\,-1 do\\n      if i-stride_gap>next_i or i==start then\\n        selection.Select(i)\\n      else\\n        next_i = i-stride-stride_gap\\n      end\\n    end\\n  end\\nend\\nfunction structure.LWS(i)\\n  local gain_found = true\\n  while(gain_found) do\\n    local s_0 = current.GetScore()\\n    structure.LocalWiggleSelected(i)\\n    gain_found = current.GetScore()>s_0+1\\n  end\\nend\\nfunction check_score(a\\\,b\\\,th)\\n  if a-b>th then\\n    print('Gain found: '..a\\\,' +'..(a-b))\\n    b = a\\n  end\\n  return b\\nend\\nfunction _main_()\\n  local stride = 2\\n  local stride_gap = 2\\n  local boost = 2\\n  local k = structure.GetCount()-stride\\n  local segs = structure.GetCount()\\n  local s0 = current.GetScore()\\n  local s1 = current.GetScore()\\n  local maxstride = segs\\n  local iters = 1\\n  local start = 1\\n  local thresh = 0.001\\n  print('RAIN LWS-SG script\\\\nSegments: '..k..'\\\\n')\\n  recentbest.Save()\\n  while(stride<maxstride) do\\n    print('Stride: '..stride..'\\\\nScore: '..s0)\\n    selection.DeselectAll()\\n    selection.Highlight('up'\\\,segs\\\,start\\\,stride\\\,stride_gap)\\n    structure.LWS(iters)\\n    recentbest.Restore()\\n    s0 = check_score(current.GetScore()\\\,s0\\\,thresh)\\n    selection.DeselectAll()\\n    selection.Highlight('down'\\\,segs\\\,start\\\,stride\\\,stride_gap)\\n    structure.LWS(iters)\\n    recentbest.Restore()\\n    s0 = check_score(current.GetScore()\\\,s0\\\,thresh)\\n    stride = stride + boost\\n    k = segs - stride\\n  end\\nend\\n\\nxpcall(_main_\\\,absolutebest.Restore)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"3\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1658456592" : "{\n \"desc\" : \"RB segments by stride. Press Ctrl+N to restore best pose.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"RB (BY-STRIDE) - SG\"\n \"parent\" : \"101702\"\n \"parent_mrid\" : \"202318\"\n \"player_id\" : \"0\"\n \"script\" : \"-- LWS-SG --\\nfunction selection.SelectNeighbor(start\\\,stop\\\,dist)\\n  local k = structure.GetCount()\\n  for i=1\\\,k do\\n    if selection.IsSelected(i)==false then\\n      for j=start\\\,stop do\\n        if math.abs(structure.GetDistance(i\\\,j))<dist then\\n           selection.Select(i)\\n           break\\n        end\\n      end -- loopf\\n    end -- testi\\n  end -- loopf\\nend\\nfunction structure.Fuze()\\n  behavior.SetClashImportance(.1)\\n  structure.WiggleAll(1)\\n  behavior.SetClashImportance(1)\\n  structure.WiggleAll(1)\\nend\\nfunction structure.SmartWiggle (s)\\n  local min_gain = 1\\n  local gain_found = true\\n  while(gain_found) do\\n    local s_0 = current.GetScore()\\n    structure.WiggleAll(s)\\n    gain_found = current.GetScore() > s_0 + min_gain\\n  end -- loopw\\nend\\nfunction _main_()\\n  local stride = 2\\n  local boost = 2\\n  local k = structure.GetCount()-stride\\n  local segs = structure.GetCount()\\n  local s0 = current.GetScore()\\n  local s1 = current.GetScore()\\n  local maxstride = 8\\n  local iters = 1\\n  local start = 1\\n  local spread = 2\\n  local thresh = 0.001\\n  local fuze_thresh = 10\\n  local rb_attempts = 4\\n  print('RB-SG script\\\\nSegments: '..segs..'\\\\n')\\n  recentbest.Save()\\n  print('Score: '..s0..'\\\\n')\\n  while(1) do\\n    while(stride<maxstride) do\\n      print('Stride: +'..stride..'\\\\n')\\n      for i=start\\\,k do\\n        for j=1\\\,rb_attempts do\\n          recentbest.Restore()\\n          selection.DeselectAll()\\n          selection.SelectRange(i\\\,(i+stride) or segs)\\n          structure.RebuildSelected(iters)\\n          selection.SelectNeighbor(i\\\,(i+stride) or segs\\\,9)\\n          structure.ShakeSidechainsSelected(iters)\\n          if current.GetScore()<0 then\\n            behavior.SetClashImportance(.1)\\n            structure.WiggleAll(1)\\n            behavior.SetClashImportance(1)\\n          end\\n          local s2 = current.GetScore()\\n          structure.SmartWiggle(iters)\\n          s1 = current.GetScore()\\n          if s1-s2<1 then\\n            structure.LocalWiggleSelected(iters)\\n            structure.SmartWiggle(iters)\\n          end\\n          s1 = current.GetScore()\\n          if s0 ~= s1 and s1+fuze_thresh>s0 then\\n            structure.Fuze()\\n          end\\n        end -- loopf\\n        recentbest.Restore()\\n        s1 = current.GetScore()\\n        if (s1-s0)>thresh then\\n          print('Segments '..i..' - '..(i+stride)..'\\\\n')\\n          print('Gain found: '..s1\\\,' +'..(s1-s0)..'\\\\n')\\n          s0 = s1\\n          save.Quicksave(3)\\n        end\\n      end--loopf\\n      stride = stride + boost\\n      k = segs - stride\\n    end--loopw\\n    stride = 2\\n    k = segs - stride\\n  end--loopw\\nend--func\\n\\nxpcall(_main_\\\,absolutebest.Restore)\\n\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"3\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1733810929" : "{\n \"desc\" : \"Tries to make protein more compact. All options at end. \"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"29523\"\n \"mrid\" : \"45297\"\n \"name\" : \"Repost Compressor v1.8.1\"\n \"parent\" : \"17939\"\n \"parent_mrid\" : \"28831\"\n \"player_id\" : \"99169\"\n \"script\" : \"--[[\\n    Rav3n_pl Compressor v1.7\\n    trying to compress protein\\n    options at end\\n]]--\\n\\n--[[\\nTlaloc`s math library\\n------------------------------------------------------------------------\\nThe original random script this was ported from has the following notices:\\nCopyright (c) 2007 Richard L. Mueller\\nHilltop Lab web site - http://www.rlmueller.net\\nVersion 1.0 - January 2\\\, 2007\\nYou have a royalty-free right to use\\\, modify\\\, reproduce\\\, and\\ndistribute this script file in any way you find useful\\\, provided that\\nyou agree that the copyright owner above has no warranty\\\, obligations\\\,\\nor liability for such use.\\n------------------------------------------------------------------------\\n]]--\\nlocal lngX = 1000\\nlocal lngC = 48313\\n\\nlocal function _MWC()\\n    local A_Hi = 63551\\n    local A_Lo = 25354\\n    local M = 4294967296\\n    local H = 65536\\n\\n    local S_Hi = math.floor(lngX / H)\\n    local S_Lo = lngX - (S_Hi * H)\\n    local C_Hi = math.floor(lngC / H)\\n    local F1 = A_Hi * S_Hi\\n    local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi\\n \\n    lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)\\n    lngX = lngX - (math.floor(lngX / M) * M)\\n    lngC = math.floor((F2 / H) + F1)\\n\\n    return lngX\\nend\\n\\nlocal function _abs(value)\\n    if value < 0 then\\n        return -value\\n    else\\n        return value\\n    end\\nend\\n\\nlocal function _floor(value)\\n    return value - (value % 1)\\nend\\n\\nlocal function _randomseed(s)\\n    if s==nil then \\n        s=math.abs(get_score(true))\\n        s=s%0.001\\n        s=1/s\\n        while s<10000000 do s=s*10 end\\n        s=s-s%1\\n    end\\n    lngX = s\\nend\\n\\nlocal function _random(m\\\,n)\\n    if n == nil and m ~= nil then\\n        n = m\\n        m = 1\\n    end\\n    if (m == nil) and (n == nil) then\\n        return _MWC() / 4294967296\\n    else\\n        if n < m then\\n            return nil\\n        end\\n        return math.floor((_MWC() / 4294967296) * (n - m + 1)) + m\\n    end\\nend\\n\\nmath=\\n{\\n    abs = _abs\\\,\\n    floor = _floor\\\,\\n    random = _random\\\,\\n    randomseed = _randomseed\\\,\\n}\\n\\n--[[ End math library ]]--\\nfunction Score()\\n    return get_score(true)\\nend\\n\\nsegCnt=get_segment_count()\\np=print\\n\\nfunction round(x)--cut all afer 3-rd place\\n    return x-x%0.001\\nend\\nfunction down(x)\\n    return x-x%1\\nend\\n\\nfunction Wiggle(how\\\, iters\\\, minppi)\\n    if how==nil then how=\\\"wa\\\" end\\n    if iters==nil then iters=6 end\\n    if minppi==nil then minppi=0.1 end\\n\\n    if iters>0 then\\n        iters=iters-1\\n        sp=Score()\\n        if how == \\\"s\\\" then do_shake(1)\\n            elseif how == \\\"wb\\\" then do_global_wiggle_backbone(2)\\n            elseif how == \\\"ws\\\" then do_global_wiggle_sidechains(2)\\n            elseif how == \\\"wa\\\" then do_global_wiggle_all(2)\\n        end\\n        ep = Score()\\n        ig=ep-sp\\n        if how~=\\\"s\\\" then\\n            if ig > minppi then return Wiggle(how\\\, iters\\\, minppi) end\\n        end\\n    end\\nend\\nfunction AllLoop() --turning entire structure to loops\\n    local ok=false\\n    for i=1\\\, segCnt do\\n        local s=get_ss(i)\\n        if s~=\\\"L\\\" then\\n            save_structure()\\n            ok=true\\n            break\\n        end\\n    end\\n    if ok then\\n        select_all()\\n        replace_ss(\\\"L\\\")\\n    end\\nend\\nfunction BlueFuse()\\n    reset_recent_best()\\n    select_all()\\n    set_behavior_clash_importance(0.05)\\n    do_shake(1)\\n    set_behavior_clash_importance(1)\\n    Wiggle()\\n    set_behavior_clash_importance(0.07)\\n    do_shake(1)\\n    set_behavior_clash_importance(1)\\n    Wiggle()\\n    restore_recent_best()\\n    set_behavior_clash_importance(0.3)\\n    do_global_wiggle_all(1)\\n    set_behavior_clash_importance(1)\\n    Wiggle()\\n    restore_recent_best()\\n    SaveBest()\\nend\\n\\nbestScore=Score()\\nfunction SaveBest()\\n    local g=Score()-bestScore\\n    if g>0 then\\n        p(\\\"Gained another \\\"\\\,round(g)\\\,\\\" pts.\\\")\\n        bestScore=Score()\\n        quicksave(3)\\n    end\\nend\\nfunction FuseEnd()\\n    set_behavior_clash_importance(1)\\n    Wiggle()\\n    Wiggle(\\\"s\\\"\\\,1)\\n    Wiggle()\\nend\\nfunction Fuze1(ci1\\\,ci2)\\n    set_behavior_clash_importance(ci1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    set_behavior_clash_importance(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    FuseEnd()\\nend\\nfunction Fuze2(ci1\\\,ci2)\\n    set_behavior_clash_importance(ci1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    set_behavior_clash_importance(1)\\n    Wiggle()\\n    set_behavior_clash_importance(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    FuseEnd()\\nend\\nfunction PinkFuse(slot)\\n    reset_recent_best()\\n    quicksave(slot) -- store state before fuse\\n    Fuze1(0.1\\\,0.7)\\n    quickload(slot) -- load state before fuse\\n    Fuze1(0.3\\\,0.6)\\n    quickload(slot) -- load state before fuse\\n    Fuze2(0.5\\\,0.7)\\n    quickload(slot) -- load state before fuse\\n    Fuze2(0.7\\\,0.5)\\n    restore_recent_best()\\n    SaveBest()\\nend\\nfunction qStab()\\n    select_all()\\n    set_behavior_clash_importance(0.1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    if fastStab==false then\\n        set_behavior_clash_importance(0.4)\\n        Wiggle()\\n        set_behavior_clash_importance(1)\\n        Wiggle(\\\"s\\\"\\\,1)\\n    end\\n    set_behavior_clash_importance(1)\\n    Wiggle()\\n    SaveBest()\\nend\\n\\nfunction MakeBands(num)\\n    local done=false\\n    local s1=math.random(segCnt)\\n    local s2=math.random(segCnt)\\n    if s1>s2 then s1\\\,s2=s2\\\,s1 end\\n    local d=get_segment_distance(s1\\\,s2)\\n\\n    if s2-s1>=minSkip and d>=minDist and d<=maxDist then done=true end\\n    local ss1=get_ss(s1)\\n    local ss2=get_ss(s2)\\n\\n    if (done and noLoops) then\\n        if ss1==\\\"L\\\" or ss2==\\\"L\\\" then done=false end\\n    end\\n\\n    if (done and structure) then\\n        if ss1==\\\"L\\\" or ss2==\\\"L\\\" then done=false end\\n    end\\n\\n    if (done and S2H) then\\n        if (ss1==\\\"E\\\" or ss2==\\\"E\\\") and (ss1==\\\"H\\\" or ss2==\\\"H\\\") and (ss1~=ss2) then\\n            done=true\\n        else\\n            done=false\\n        end\\n    end\\n\\n    if done then\\n        num=num-1\\n        band_add_segment_segment(s1\\\,s2)\\n        k=get_band_count()\\n        local len=d-compressFrac\\n        if len<3.5 then len=3.5 end\\n        if len>20 then len=20 end\\n        band_set_length(k\\\,len)\\n        bands[\\\#bands+1]={s1\\\,s2}\\n    end\\n\\n    if num>0 then return MakeBands(num) end --tail call\\nend\\nbands={}\\nfunction Repeat_bands(bands)\\n    band_delete()\\n    for i=1\\\,\\\#bands do\\n        local s1=bands[i][1]\\n        local s2=bands[i][2]\\n        band_add_segment_segment(s1\\\,s2)\\n        local k=get_band_count()\\n        local d=get_segment_distance(s1\\\,s2)\\n        local len=d-compressFrac\\n        if len<3.5 then len=3.5 end\\n        if len>20 then len=20 end\\n        band_set_length(k\\\,len)\\n    end\\nend\\nfunction Bandstr(str) --set all band strengt\\n    if str<0.1 then str=0.1 end\\n    if str>10 then str=10 end\\n    for i=1\\\, get_band_count() do\\n        band_set_strength(i\\\, str)\\n    end\\nend\\nfunction SaveRB(slot)\\n    quicksave(slot)\\n    restore_recent_best()\\n    SaveBest()\\n    quickload(slot)\\nend\\n\\nlastBands=0.25\\nfunction Compressor(numTries)\\n    p(\\\"Starting Compressor 1.8\\\, \\\"\\\,numTries\\\,\\\" loops.\\\")\\n    quicksave(3)\\n    quicksave(7) --save state for losing\\n    badOnes=0\\n    reset_recent_best()\\n    if allLoop then AllLoop() end\\n    local sscore=Score()\\n    for i=1\\\,numTries do\\n        loss=Score()*percLoss/100 --pulling till we lost some points\\n        band_delete()\\n        bands={}\\n        MakeBands(numBands)\\n        local best=false\\n        repeat\\n            if best==true and repeatGood==true then\\n\\t\\t\\t\\tbest=false\\n                p(\\\"Repeating last bands.\\\")\\n                Repeat_bands(bands)\\n                i=i+1\\n            end\\n            local ls=Score()\\n            p(\\\"Compress loop \\\"\\\,i\\\,\\\" of \\\"\\\,numTries\\\,\\\" started. Current score: \\\"\\\,round(ls))\\n            set_behavior_clash_importance(pullingCI)\\n            select_all()\\n            reset_recent_best()\\n            if slowBands then\\n                for str=lastBands\\\,bandStr\\\,0.07 do--search enough band strenght to move\\n                    restore_recent_best()--because sometimes it makes points during pull :D\\n                    ss=Score()\\n                    Bandstr(str)\\n                    Wiggle(\\\"wb\\\"\\\,1)\\n                    if ss-Score()>loss then\\n                        lastBands=str-0.1\\n                        break\\n                    end\\n                end\\n            else\\n                Bandstr(bandStr)\\n                Wiggle(\\\"wb\\\"\\\,1)\\n            end\\n            SaveRB(4) --because sometimes it missing fractions\\n            band_delete()\\n            qStab()\\n            SaveBest()\\n            if Score()> (bestScore-fuzeScore) then\\n                if useBF then \\n                    quicksave(4)\\n                    BlueFuse()                     \\n                    quickload(4)\\n                end\\n                if usePF then PinkFuse(4) end\\n            end\\n            if maxLoss>0 then\\n                if Score()>bestScore-maxLoss then\\n                    quicksave(7) --save actual \\\"best\\\" solution\\n                else\\n                    badOnes=badOnes+1\\n                    if badOnes >=reloadBest then\\n                        badOnes=0\\n                        quickload(3)\\n                    else\\n                        quickload(7) --load \\\"second best\\\"\\n                    end\\n                end\\n            else\\n                quickload(3)\\n            end\\n            local es=Score()\\n            if es>ls then best=true else best=false end --and es==bestScore --repeating all bands making points\\n            p(\\\"Loop \\\"\\\,i\\\,\\\" gain \\\"\\\,round(es-ls)\\\,\\\" ;total gain \\\"\\\,round(bestScore-sscore))\\n        until best~=true\\n    end\\n    quickload(3)\\n    if allLoop then load_structure() end\\n    p(\\\"Total gain: \\\"\\\,round(Score()-sscore))\\nend\\n\\nminDist=10 --minimum spatial distance between banding segments\\nmaxDist=24 --maximum spatial distance between banding segments\\ncompressFrac=4 --make bands shorter by that much points\\nminSkip=5 --minimum segment distance between banded segments\\nnumBands=7 --how many bands use at once\\n\\nfuzeScore=5 --how close we have to be to run BF/PF\\nusePF=true --true --use PinkFuse after qStab\\nuseBF=false --true --use BlueFuse after qStab.\\n            --fuzes are started form SAME state\\\, NOT one after one!\\nfastStab=true --only 1 snake and wiglle when true\\n            \\nallLoop=false --work in all-loop mode. sometimes work better than structure mode :)\\n\\nS2H=false --true --all bands are between sheets and helixes\\nstruct=false --all bands have at least one end on structure (not loop)\\nnoLoops=false --band cant have end on loop\\n\\nbandStr=1.0 -- max band strenght\\nslowBands=false --true --bands strenght are raised few times till score drops by %\\npercLoss=2 --pulling stops when score drops by that percent (ie 200pts when 10k pts)\\nrepeatGood=true --repeating good bands\\n\\npullingCI=0.3  --clash impotrance during pull\\nmaxLoss=150 --maximum acceptable LOSS after BF/PF. also lowering fuzeScore\\nreloadBest=5 --reload best solution after that many worst ones\\n\\n\\nCompressor(1000) --go! 1000 times :)\\n\\n\\n\\n\"\n \"script_version\" : \"1\"\n \"share_scope\" : \"538970679\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1735288566" : "{\n \"desc\" : \"Pushes away segment using few bands. Then stabilise. Now pushing direction is reandomized. v2-now it pulls after pushing. All options at end.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"16088\"\n \"mrid\" : \"32967\"\n \"name\" : \"Rav3n_pl Push v2.5\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"174969\"\n \"script\" : \"--[[\\nPush v2\\nrandomly pushes then pulls one segment\\noptions at end\\n]]--\\n\\n\\np = print --a short\\nsegmentCount =  get_segment_count()\\nsegCnt=segmentCount\\nfunction Score()--return score\\\, negative too\\n    return get_score(true)\\nend\\n\\nfunction Wiggle(how\\\, iters\\\, minppi) --score conditioned recursive wiggle/shake\\n    if how==nil then how=\\\"wa\\\" end\\n    if iters==nil then iters=6 end\\n    if minppi==nil then minppi=0.1 end\\n    if \\\"how\\\"==\\\"s\\\" then iters=1 end\\n    if iters>0 then\\n        iters=iters-1\\n        local sp=Score()\\n        if how == \\\"s\\\" then do_shake(1) \\n            elseif how == \\\"wb\\\" then do_global_wiggle_backbone(2)\\n            elseif how == \\\"ws\\\" then do_global_wiggle_sidechains(2)\\n            elseif how == \\\"wa\\\" then do_global_wiggle_all(2)\\n        end\\n        local ig=Score()-sp\\n        if ig > minppi then return Wiggle(how\\\, iters\\\, minppi) end --to learn recursion you have to learn recursion ;]\\n    end\\nend\\nfunction FuseEnd()\\n    set_behavior_clash_importance(1)\\n    Wiggle()\\n    Wiggle(\\\"s\\\"\\\,1)\\n    Wiggle()\\nend\\nfunction Fuze1(ci1\\\,ci2)\\n    set_behavior_clash_importance(ci1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    set_behavior_clash_importance(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    FuseEnd()\\nend\\nfunction Fuze2(ci1\\\,ci2)\\n    set_behavior_clash_importance(ci1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    set_behavior_clash_importance(1)\\n    Wiggle()\\n    set_behavior_clash_importance(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    FuseEnd()\\nend\\nfunction PinkFuse()\\n    reset_recent_best()\\n    quicksave(4) -- store state before fuse\\n    Fuze1(0.1\\\,0.7)\\n    quickload(4) -- load state before fuse\\n    Fuze1(0.3\\\,0.6)\\n    quickload(4) -- load state before fuse\\n    Fuze2(0.5\\\,0.7)\\n    quickload(4) -- load state before fuse\\n    Fuze2(0.7\\\,0.5)\\n    restore_recent_best()\\nend\\nfunction qStab()\\n    --select_all()\\n    set_behavior_clash_importance(0.1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    if fastQstab==false then\\n        set_behavior_clash_importance(0.6)\\n        Wiggle()\\n        set_behavior_clash_importance(1)\\n        Wiggle(\\\"s\\\"\\\,1)\\n    end\\n    set_behavior_clash_importance(1)\\n    Wiggle()\\nend\\nbestScore=Score()\\nfunction SaveBest()\\n    local g=Score()-bestScore\\n    if g>0 then\\n        p(\\\"Gained another \\\"\\\,round(g)\\\,\\\" pts.\\\")\\n        bestScore=Score()\\n        quicksave(3)\\n    end\\nend\\n\\n--[[\\nTlaloc`s math library\\n------------------------------------------------------------------------\\nThe original random script this was ported from has the following notices:\\nCopyright (c) 2007 Richard L. Mueller\\nHilltop Lab web site - http://www.rlmueller.net\\nVersion 1.0 - January 2\\\, 2007\\nYou have a royalty-free right to use\\\, modify\\\, reproduce\\\, and\\ndistribute this script file in any way you find useful\\\, provided that\\nyou agree that the copyright owner above has no warranty\\\, obligations\\\,\\nor liability for such use.\\n------------------------------------------------------------------------\\n]]--\\nlocal lngX = 1000\\nlocal lngC = 48313\\n\\nlocal function _random(m\\\,n)\\n    local A_Hi = 63551\\n    local A_Lo = 25354\\n    local M = 4294967296\\n    local H = 65536\\n    \\n    function _MWC()\\n        local S_Hi = math.floor(lngX / H)\\n        local S_Lo = lngX - (S_Hi * H)\\n        local C_Hi = math.floor(lngC / H)\\n        local F1 = A_Hi * S_Hi\\n        local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi\\n     \\n        lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)\\n        lngX = lngX - (math.floor(lngX / M) * M)\\n        lngC = math.floor((F2 / H) + F1)\\n\\n        return lngX\\n    end\\n    \\n    if n == nil and m ~= nil then\\n        n = m\\n        m = 1\\n    end\\n    if (m == nil) and (n == nil) then\\n        return _MWC() / M\\n    else\\n        if n < m then\\n            return nil\\n        end\\n        return math.floor((_MWC() / M) * (n - m + 1)) + m\\n    end\\nend\\n\\nlocal function _abs(value)\\n    if value < 0 then\\n        return -value\\n    else\\n        return value\\n    end\\nend\\n\\nlocal function _floor(value)\\n    return value - (value % 1)\\nend\\n\\nlocal function _randomseed(s)\\n    if s==nil then \\n        s=math.abs(get_score(true))\\n        s=s%0.001\\n        s=1/s\\n        while s<10000000 do s=s*10 end\\n        s=s-s%1\\n    end\\n    lngX = s\\nend\\n\\nmath=\\n{\\n    abs = _abs\\\,\\n    floor = _floor\\\,\\n    random = _random\\\,\\n    randomseed = _randomseed\\\,\\n}\\nmath.randomseed()\\n--[[ End math library ]]--\\n\\nfunction down(x)--cut all after comma\\n    return x-x%1\\nend\\nfunction round(x)--cut all afer 3-rd place\\n    return x-x%0.001\\nend\\nfunction SaveRB(slot)\\n    quicksave(slot)\\n    restore_recent_best()\\n    SaveBest()\\n    quickload(slot)\\nend\\n\\nbigBRK=0\\nfunction MakeBands(sgn\\\,bands\\\,center)\\n    local SC = get_segment_distance(sgn\\\,center)\\n    local search=true\\n    local sg2\\\, SR\\\, RC\\n    local brk=0\\n    repeat --try determine that band can push in good direction\\n        brk=brk+1\\n        sg2=math.random(segmentCount)\\n        RC=get_segment_distance(sg2\\\,center)\\n        SR=get_segment_distance(sg2\\\,sgn)\\n        if SR<15\\n            and RC<SC-3\\n            and math.abs(sg2-sgn)>5\\n            and math.abs(sg2-center)>3\\n        then search=false end\\n        if brk>segmentCount then break end\\n    until search==false\\n    if brk<segmentCount then\\n        band_add_segment_segment(sgn\\\, sg2)\\n        if push then\\n            SR=SR+pushDst --push x units\\n        else\\n            SR=SR-pushDst --pulls x units\\n        end\\n        if SR>20 then SR=20 end\\n        if SR<3 then SR=3 end\\n        band_set_length(get_band_count()\\\, SR)\\n        bands=bands-1\\n        ppoints[\\\#ppoints+1]=sg2\\n    else\\n        bigBRK=bigBRK+1\\n    end\\n    if bands >0 and bigBRK<10 then return MakeBands(sgn\\\,bands\\\,center) end --make next band\\nend\\nppoints={}\\nfunction Push(sgn)\\n    local ssc=Score()\\n    if push then\\n        p(\\\"Pushing segment \\\"\\\,sgn\\\, \\\" score: \\\"\\\,round(ssc))\\n    else\\n        p(\\\"Pulling segment \\\"\\\,sgn\\\, \\\" score: \\\"\\\,round(ssc))\\n    end\\n    band_delete()\\n    quicksave(3)\\n    reset_recent_best()\\n    ppoints={}\\n    bigBRK=0\\n    MakeBands(sgn\\\,numBands\\\,cntSeg)\\n    if get_band_count()>0 then\\n        if doPlatform then --stabilize pushing point\\n            for i=1\\\,\\\#ppoints do\\n                local sn=ppoints[i]\\n                for x=i\\\,\\\#ppoints do\\n                    local sn2=ppoints[x]\\n                    band_add_segment_segment(cntSeg\\\, sn)\\n                    band_set_length(get_band_count()\\\, get_segment_distance(sn\\\,cntSeg))\\n                    band_add_segment_segment(sn2\\\, sn)\\n                    band_set_length(get_band_count()\\\, get_segment_distance(sn\\\,sn2))\\n                end\\n            end\\n        end\\n        if doFreeze>0 then\\n            local ss=sgn-doFreeze\\n            local se=sgn+doFreeze\\n            if ss<1 then ss=1 end\\n            if se>segmentCount then se=segmentCount end\\n            deselect_all()\\n            select_index_range(1\\\,ss)\\n            select_index_range(se\\\,segmentCount)\\n            do_freeze(true\\\,false)\\n        end\\n        select_all()\\n        --deselect_all()\\n        --SelectAround(326\\\,338\\\,15)\\n        set_behavior_clash_importance(wiggleCI)\\n        Wiggle(\\\"wb\\\"\\\,1)\\n        SaveRB(4) --maybe it found some already?\\n        set_behavior_clash_importance(1)\\n        band_delete()\\n        do_unfreeze_all()\\n        --deselect_all()\\n        --SelectAround(326\\\,338\\\,15)\\n        qStab()\\n        if doPF and  Score()>bestScore-PFthreshold then\\n            PinkFuse()\\n        end\\n        SaveBest()\\n        quickload(3)\\n        local g=round(Score()-ssc)\\n        if g>0 then p(\\\"Push gain: \\\"\\\,g) end\\n    else\\n        p(\\\"Can`t make proper bands\\\")\\n    end\\nend\\nfunction CanBeUsed(sn)\\n    local can=false\\n    if \\\#alwaysUse>0 then\\n        for i=1\\\,\\\#alwaysUse do\\n            local ss=alwaysUse[i][1]\\n            local se=alwaysUse[i][2]\\n            if sn>=ss and sn<=se then\\n                can=true\\n                break\\n            end\\n        end\\n    else\\n        can=true\\n    end\\n    return can\\nend\\n\\nfunction SelectAround(ss\\\,se\\\,radius)\\n    for i=1\\\, segCnt do\\n        for x=ss\\\,se do\\n            if get_segment_distance(x\\\,i)<radius then select_index(i) break end\\n        end \\n    end\\nend\\n\\nfunction RandomPush(pushes)\\n    if push==true then p(\\\"Pushing away from \\\"\\\,cntSeg)\\n    else p(\\\"Pulling to \\\"\\\,cntSeg) end\\n    \\n    for i=1\\\,pushes do\\n        local search=true\\n        local sn\\n        local t=0\\n        repeat\\n            t=t+1\\n            sn=math.random(segmentCount)\\n            local dst=get_segment_distance(sn\\\, cntSeg)\\n            if dst>minDist and CanBeUsed(sn) then search=false end\\n            if t>10 then break end\\n        until search==false\\n        if t<10 then Push(sn) end\\n    end\\nend\\n\\nalwaysUse={ --always push that area/areas\\n--{326\\\,338}\\\, --391\\n--{1\\\,100}\\\,\\n--{150\\\,170}\\\,\\n}\\ncntSeg=0 --\\\"center\\\" segment global variable\\\, segment to push from. now randomized\\n\\nnumBands=5 --how many bands should push (max\\\, sometimes less)\\nwiggleCI=0.9 --pusching Clash Importance\\n\\ndoPF=true --false --use pink fuze\\nPFthreshold=-1 --PinkFuze if we so close to best score after qSatb\\nfastQstab=false --true --only 1s 1w if true\\n\\nminDist=8 --minimum distance from \\\"center\\\" to push segment\\npushDst=4 --push/pull how far away\\ndoPlatform=false --true --makes additional bands to center to stabilize push points\\ndoFreeze=0 --10 --if positve freezes entire protein except for area around pushed segment\\n            -- set to 0 to disable freeze\\n\\n--Push(78) --run that way to push desired segment\\nwhile true do\\n    cntSeg=math.random(segmentCount)\\n    push=true\\n    RandomPush(3) --10 pushes from that segment\\n    push=false\\n    RandomPush(3) --10 pulls to that segment\\nend\\n\\n\\n\\n\\n\\n\"\n \"script_version\" : \"1\"\n \"share_scope\" : \"1735289203\"\n \"type\" : \"script\"\n \"uses\" : \"1\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1827602689" : "{\n \"desc\" : \"wa BlueFuse\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"BF (SIMPLE) -SG\"\n \"parent\" : \"101707\"\n \"parent_mrid\" : \"202323\"\n \"player_id\" : \"0\"\n \"script\" : \"-- BF-SG --\\nfunction round(n\\\,r)\\n  local R = r\\n  if r == nil then R = 1 end\\n  return n - (n%math.pow(10\\\,-R))\\nend\\nfunction structure.SmartWiggle(s)\\n  local th = 1\\n  local gain_found = true\\n  while(gain_found) do\\n    local c_0 = current.GetScore()\\n    structure.WiggleAll(s)\\n    gain_found = current.GetScore()>c_0+th\\n  end -- loopw\\nend\\nfunction check_score(a\\\,b\\\,th\\\,ci)\\n  if a-b>th then\\n    print('Gain found: '..a\\\,' +'..(a-b)\\\,ci)\\n    b = a\\n  end\\n  return b\\nend\\nfunction _main_()\\n  recentbest.Save()\\n  local s_0 = current.GetScore()\\n  local s_1 = current.GetScore()\\n  local thresh = 0.001\\n  local iters = 3\\n  local ci = 0.10\\n  local step = 0.05\\n  local roof = 0.5\\n  print('SIMPLE BF-SG recipe\\\\nCurrent Score: '..s_0)\\n  while(1) do\\n    behavior.SetClashImportance(ci)\\n    structure.WiggleAll(iters\\\,true\\\,false)\\n    structure.ShakeSidechainsAll(iters)\\n    behavior.SetClashImportance(1)\\n    structure.SmartWiggle(iters)\\n    s_1 = current.GetScore()\\n    local no_gain = s_1 < s_0\\n    s_0 = check_score(s_1\\\,s_0\\\,thresh\\\,ci)\\n    if no_gain then\\n      ci = (ci + step)%roof\\n    end\\n  end -- loopw\\nend\\n\\nxpcall(_main_\\\,absolutebest.Restore)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"15\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1875402749" : "{\n \"desc\" : \"BlueFuse\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"BF-SG\"\n \"parent\" : \"101707\"\n \"parent_mrid\" : \"202323\"\n \"player_id\" : \"0\"\n \"script\" : \"-- BF-SG --\\nfunction structure.SmartWiggle(s)\\n  local th = 1\\n  local gain_found = true\\n  while(gain_found) do\\n    local c_0 = current.GetScore()\\n    structure.WiggleAll(s)\\n    gain_found = current.GetScore()>c_0+th\\n  end -- loopw\\nend\\nfunction check_score(a\\\,b\\\,th\\\,ci)\\n  if a-b>th then\\n    print('Gain found: '..a\\\,' +'..(a-b)\\\,ci)\\n    b = a\\n  end\\n  return b\\nend\\nfunction _main_()\\n  recentbest.Save()\\n  local s_0 = current.GetScore()\\n  local s_1 = current.GetScore()\\n  local thresh = 0.001\\n  local iters = 3\\n  local ci = 0.10\\n  local step = 0.05\\n  local roof = 0.5\\n  print('BF-SG recipe\\\\nCurrent Score: '..s_0)\\n  while(1) do\\n    behavior.SetClashImportance(ci)    \\n    structure.ShakeSidechainsAll(1)\\n    behavior.SetClashImportance(1)    \\n    structure.SmartWiggle(iters)\\n    behavior.SetClashImportance(ci)\\n    structure.WiggleAll(iters\\\,true\\\,false)\\n    behavior.SetClashImportance(1)\\n    structure.SmartWiggle(iters)\\n    s_1 = current.GetScore()\\n    local no_gain = s_1 < s_0\\n    s_0 = check_score(s_1\\\,s_0\\\,thresh\\\,ci)\\n    if no_gain then\\n      ci = (ci + step)%roof\\n    end\\n  end -- loopw\\nend\\n\\nxpcall(_main_\\\,absolutebest.Restore)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"15\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_1900978783" : "{\n \"desc\" : \"wb at low ci then perform local sh walkthrough culminating with wa + sh\\\, repeat\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"QR-FUSE-SG\"\n \"parent\" : \"101701\"\n \"parent_mrid\" : \"202317\"\n \"player_id\" : \"0\"\n \"script\" : \"-- QR-FUSE-SG --\\nfunction structure.SmartWiggle(s)\\n  local gain_found = true\\n  local thresh = 1\\n  while (gain_found) do\\n    local s_0 = current.GetScore()\\n    structure.WiggleAll(s)\\n    gain_found = current.GetScore()>s_0+thresh\\n  end\\nend\\nfunction check_score(a\\\,b\\\,th)\\n  if (a-b)>th then\\n    print('Gain found: '..a\\\,' +'..(a-b))\\n    b = a\\n  end\\n  return b\\nend\\nfunction _main_()\\n  local iters = 1\\n  local k = structure.GetCount()\\n  local s_0 = current.GetScore()\\n  local s_1 = 0\\n  local s_2 = 0\\n  local still_gaining = true\\n  local thresh = 0.001\\n  recentbest.Save()\\n  print('QR-FUSE-SG recipe\\\\nScore: '..s_0)\\n  while(1) do\\n    selection.DeselectAll()\\n    behavior.SetClashImportance(0.10)\\n    structure.ShakeSidechainsAll(1)--structure.WiggleAll(iters\\\,true\\\,false)--wb--\\n    behavior.SetClashImportance(1)\\n    s_1 = current.GetScore()\\n    behavior.SetClashImportance(0.90)\\n    structure.WiggleAll(iters)\\n    behavior.SetClashImportance(1)\\n    structure.ShakeSidechainsAll(iters)\\n    structure.SmartWiggle(iters)\\n  --recentbest.Restore()\\n    s_0 = check_score(current.GetScore()\\\,s_0\\\,thresh)\\n  end -- loopw\\nend\\n\\nxpcall(_main_\\\,absolutebest.Restore)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_2043796908" : "{\n \"desc\" : \"RB segments (loop-only)\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"RB (LOOPS-ONLY)-SG\"\n \"parent\" : \"101703\"\n \"parent_mrid\" : \"202319\"\n \"player_id\" : \"0\"\n \"script\" : \"-- LWS-SG --\\nfunction structure.SmartWiggle(s)\\n  local gain_found = true\\n  local th = 1\\n  while(gain_found) do\\n    local s_0 = current.GetScore()\\n    structure.WiggleAll(s)\\n    gain_found = current.GetScore()>s_0+th\\n  end -- loopw\\nend\\nfunction _main_()\\nlocal stride = 2\\nlocal boost = 2\\nlocal k = structure.GetCount()-stride\\nlocal segs = structure.GetCount()\\nlocal s_0 = current.GetScore()\\nlocal s_1 = current.GetScore()\\nlocal maxstride = 8\\nlocal iters = 1\\nlocal start = 1\\nlocal spread = 2\\nlocal thresh = 0.001\\nlocal next_i = true\\nlocal next_ss = structure.GetSecondaryStructure(1)\\nprint('SSRB-SG script\\\\nSegments: '..segs..'\\\\n')\\nrecentbest.Save()\\nselection.DeselectAll()\\nprint('Score: '..s_0..'\\\\n')\\nwhile(1) do\\nfor i=start\\\,k do\\n  local ss = structure.GetSecondaryStructure(i)\\n  if ss == 'L' then\\n    selection.Select(i)\\n    next_i = true\\n  elseif next_i or i==k then\\n    behavior.SetClashImportance(0.1)\\n    structure.RebuildSelected(iters)\\n    behavior.SetClashImportance(1)\\n    structure.ShakeSidechainsSelected(iters)--\\n  --structure.WiggleSelected(iters\\\,false\\\,true)--\\n  --behavior.SetClashImportance(1)--\\n  --structure.WiggleSelected(iters\\\,true\\\,false)--\\n  --structure.WiggleSelected(iters)--(iters+spread)--\\n  --behavior.SetClashImportance(1)--\\n    structure.SmartWiggle(iters)--\\n    recentbest.Restore()\\n    s_1 = current.GetScore()\\n    if (s_1-s_0)>thresh then\\n      print('Segments '..next_i..' - '..i)\\n      print('Gain found: '..s_1\\\,' +'..(s_1-s_0)..'\\\\n')\\n      s_0 = s_1\\n    end\\n    selection.DeselectAll()\\n    next_i = false\\n  end\\nend--loopf\\nend--loopw\\nend--func\\n\\nxpcall(_main_\\\,absolutebest.Restore)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"1\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_2072435874" : "{\n \"desc\" : \"01 09 2014\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"1\"\n \"mid\" : \"49952\"\n \"mrid\" : \"106279\"\n \"name\" : \"SG2011 SCFLIP V3\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"199249\"\n \"script\" : \"--sidechain flipper 3.0 - Seagat2011\\r\\n--Iterative sidechain snap and backbone wiggle; no global ops\\r\\n\\r\\nlocal idx \\r\\nlocal _s\\r\\nlocal _n\\r\\nlocal segment_count \\r\\n\\r\\nidx = 1\\r\\nsegment_count = structure.GetCount ()\\r\\n\\r\\nrecentbest.Save ()\\r\\n\\r\\n_s = recentbest.GetScore()\\r\\n_n = recentbest.GetScore()\\r\\n\\r\\nselection.SelectAll ()\\r\\n\\r\\nprint ( \\\"Initializing.. Score: \\\"\\\,_s )\\r\\n\\r\\nwhile ( 1 ) do\\r\\n\\r\\n\\tlocal segment_index = 1\\r\\n\\tlocal rotamer_avg = 0\\r\\n\\tlocal avg_snap_count = 0\\r\\n\\tlocal snap_count = 0\\r\\n\\tlocal max_segment_count = segment_count + 1\\r\\n\\r\\n\\t-- find avg\\\# of rotamers\\r\\n\\twhile ( idx < segment_count ) do\\r\\n\\t\\tsnap_count = rotamer.GetCount ( idx )\\r\\n\\t\\tprint ( \\\"snap number.. at rotamer: \\\"\\\, idx\\\, \\\" - \\\"\\\,snap_count )\\r\\n\\t\\tavg_snap_count = snap_count + avg_snap_count\\r\\n\\t\\tidx = idx + 1\\r\\n\\tend -- idx < segment_count\\r\\n\\t\\r\\n\\tavg_snap_count =  ( avg_snap_count / segment_count ) \\r\\n\\r\\n\\t-- index those below/above avg\\\#\\r\\n\\r\\n\\tprint ( \\\"avg snap number.. per rotamer: \\\"\\\,avg_snap_count )\\r\\n\\r\\n\\t-- perform snaps on low-number rotamers\\r\\n\\tidx = 1\\r\\n\\twhile ( idx < segment_count ) do\\r\\n\\t\\tsnap_count = rotamer.GetCount ( idx )\\r\\n\\t\\tif ( snap_count < avg_snap_count ) then\\r\\n\\t\\t\\tlocal r = 1\\r\\n\\t\\t\\tprint ( \\\"Index \\\"\\\,idx\\\,\\\"(\\\"\\\,idx\\\,\\\"\\\\/\\\"\\\,segment_count\\\,\\\") - n_rotameters \\\"\\\,snap_count )\\r\\n\\t\\t\\twhile ( r < snap_count ) do\\r\\n\\t\\t\\t\\tlocal _score_at_wiggle = recentbest.GetScore()\\r\\n\\t\\t\\t\\trotamer.SetRotamer ( idx\\\,r )\\r\\n\\t\\t\\t\\tstructure.WiggleAll ( 1 )\\r\\n\\t\\t\\t\\trecentbest.Restore ()\\r\\n\\t\\t\\t\\tlocal _score_after_wiggle = recentbest.GetScore()\\r\\n\\t\\t\\t\\tif ( _score_after_wiggle > _score_at_wiggle ) then\\r\\n\\t\\t\\t\\t\\tprint (\\\"Improvement at index \\\"\\\, idx\\\, \\\".\\\"\\\,r )\\r\\n\\t\\t\\t\\t\\tprint (\\\"Gain: \\\"\\\, _score_after_wiggle\\\, \\\"  +\\\"\\\, _score_after_wiggle - _score_at_wiggle )\\r\\n\\t\\t\\t\\tend -- test for gain\\r\\n\\t\\t\\t\\tr = r + 1\\r\\n\\t\\t\\tend -- r < snap_count\\r\\n\\t\\tend -- snap_count < avg_snap_count\\r\\n\\t\\tidx = idx + 1\\r\\n\\tend -- idx < segment_count\\r\\n\\r\\n\\t-- perform snaps on remainder of rotamers\\r\\n\\tidx = 1\\r\\n\\twhile ( idx < segment_count ) do\\r\\n\\t\\tsnap_count = rotamer.GetCount ( idx )\\r\\n\\t\\tif ( snap_count > avg_snap_count ) then\\r\\n\\t\\t\\tlocal r = 1\\r\\n\\t\\t\\tprint ( \\\"Index \\\"\\\,idx\\\,\\\"(\\\"\\\,idx\\\,\\\"\\\\/\\\"\\\,segment_count\\\,\\\") - n_rotameters \\\"\\\,snap_count )\\r\\n\\t\\t\\twhile ( r < snap_count ) do\\r\\n\\t\\t\\t\\tlocal _score_at_wiggle = recentbest.GetScore()\\r\\n\\t\\t\\t\\trotamer.SetRotamer ( idx\\\,r )\\r\\n\\t\\t\\t\\tstructure.WiggleAll ( 1 )\\r\\n\\t\\t\\t\\trecentbest.Restore ()\\r\\n\\t\\t\\t\\tlocal _score_after_wiggle = recentbest.GetScore()\\r\\n\\t\\t\\t\\tif ( _score_after_wiggle > _score_at_wiggle ) then\\r\\n\\t\\t\\t\\t\\tprint (\\\"Improvement at index \\\"\\\, idx\\\, \\\".\\\"\\\,r )\\r\\n\\t\\t\\t\\t\\tprint (\\\"Gain: \\\"\\\, _score_after_wiggle\\\, \\\"  +\\\"\\\, _score_after_wiggle - _score_at_wiggle )\\r\\n\\t\\t\\t\\tend -- test for gain\\r\\n\\t\\t\\t\\tr = r + 1\\r\\n\\t\\t\\tend -- r < snap_count\\r\\n\\t\\tend -- snap_count > avg_snap_count\\r\\n\\t\\tidx = idx + 1\\r\\n\\tend -- idx < segment_count\\r\\n\\r\\n\\trecentbest.Restore ()\\r\\n\\r\\nend -- while ( 1 ) \"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_2140428172" : "{\n \"desc\" : \"Genetic Algorythm on Bands. Now more critters in herd. Herd will be reneved if no gain by given number of generations. Some points loss is accepted per critter. All options in front.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"49916\"\n \"mrid\" : \"106236\"\n \"name\" : \"Rav3n_pl GAB v0.6.1 loss\"\n \"parent\" : \"39269\"\n \"parent_mrid\" : \"80290\"\n \"player_id\" : \"199249\"\n \"script\" : \"--[[\\nGAB - Genetic Algorythm on Bands\\nby Rav3n_pl\\nbased on CartoonVillan and Crashguard303 scripts\\n\\nDefinitions:\\nband: randomised: start segment\\\, end segment\\\, length\\\, strength\\ncritter: set of bands\\nherd: set of critters\\n\\n1.\\n- randomize needed bands \\n- randomly assignig them to criters\\n\\n2.\\n- score each critter\\n\\n3.\\n- keep critters scoring above score\\n- breed best critters\\n- breed bastards (best one + random one)\\n- forget about rest of critter\\n- randomize new critters to fill herd\\n\\n]]--\\n\\n-- options:\\nenergy=false --set true to seek energy in exploration puzzles; false works on all puzzles\\npullCI=0.9 --Clash Impotrance during pull\\nfastQstab=true -- only 1s1w after pull if true\\nfuzeThresh = 1 -- run fuze if we are close to best score (negative=new best score)\\nqstabThresh=10 -- run qstab if score drops more than... wiggle only in other case\\nmaxCI=1 --changle to lower if not want tu use c=1 shake/wiggle at all. good in eraly game\\n\\nherd= --herd options\\n{ \\nbreedBest = 5\\\, --breed best 4 critters - all combinations => 6 kids form 4 critters\\\, 3 form 3\\\, 1 form 2\\\, 9 form 5 ;]\\nkeepBest = 3\\\, --save up to 3 best scoring critters\\\, rest are forgotten\\nbreedBastards = 8\\\, --number of best will have one random bastard\\nnewRandom = 10\\\, --adding new random ones each generation\\nmaxGen= 100\\\, --maximum generations \\nshuffle =  true\\\, --set true to run critters in random order\\nrenew=4\\\, --create totally fresh herd after that many gens w/o improvement\\n}\\ncritter= --critter options\\n{\\nminBands=1\\\, --minimum bands\\nmaxBands=7\\\, --maximum bands\\nkeepScore = 0.1 \\\, --survive to next gen only if score higher than\\nbreedScore=-20\\\, --will breed kids only if score higher. Basttards always breed\\nmaxLoss=30\\\, --maximum loss by critter. set 0 to disable\\n}\\n\\nbands= --bands options\\n{\\nminStr=0.3\\\, --minimum band str\\nmaxStr=1.1\\\, --maximum band str\\nminChng = 3\\\, -- minimum change of band len accordig to current distance\\nmaxUp = 7.1\\\, -- maximum chnage up (push)\\nmaxDn = 7.9\\\, -- maximum change down (pull)\\nminSkip = 10\\\, --minimum segment distance\\nminDist = 4\\\, --minimum spatial distance\\nminLen = 2\\\, --minimum lenght of created band\\n}\\n\\nDoNotUse={--just comment lines below or add more areas to avoid\\n--{segCnt\\\,segCnt}\\\, --ligand cant be used\\n--{120\\\,134}\\\,\\n--{1\\\,10}\\\,\\n}\\nAlwaysUse={ --areas should be always used\\n--{segCnt\\\,segCnt}\\\,--ligand need to be at one end\\n--{308\\\,311}\\\, --loopy\\n--{272\\\,319}\\\, --loopy\\n}\\n\\n-- bands by secondary structure\\nuse=\\n{\\nSheet=true\\\, --set false to not band sheets\\nHelix=true\\\, --set false to not band helices\\nLoop=true\\\, --set false to not band loops\\n}\\ncheckBoth=false --check both ends to above\\\, if false only one end need to be true\\n\\n--end of options\\n\\nsegCnt=get_segment_count()\\np=print\\nfunction CI(c)\\nif c>maxCI then c=maxCI end\\nset_behavior_clash_importance(c)\\nend\\n\\nfunction round(x)--cut all afer 3-rd place\\n    return x-x%0.001\\nend\\nfunction down(x)\\n    return x-x%1\\nend\\n\\nfunction Score()--return score\\\, exploration too\\n    if energy==true then\\n        return get_score(true)\\n    else\\n        return get_ranked_score(true)\\n    end\\nend \\n\\nfunction Wiggle(how\\\, iters\\\, minppi)\\n    if how==nil then how=\\\"wa\\\" end\\n    if iters==nil then iters=6 end\\n    if minppi==nil then minppi=0.1 end\\n    \\n    if iters>0 then\\n        iters=iters-1\\n        sp=Score()\\n        if how == \\\"s\\\" then do_shake(1)\\n            elseif how == \\\"wb\\\" then do_global_wiggle_backbone(2)\\n            elseif how == \\\"ws\\\" then do_global_wiggle_sidechains(2)\\n            elseif how == \\\"wa\\\" then do_global_wiggle_all(2) \\n        end\\n        ep = Score()\\n        ig=ep-sp\\n        if how~=\\\"s\\\" then\\n            if ig > minppi then return Wiggle(how\\\, iters\\\, minppi) end --tail call\\n        end\\n    end\\nend\\n\\n--[[\\nTlaloc`s math library\\n------------------------------------------------------------------------\\nThe original random script this was ported from has the following notices:\\nCopyright (c) 2007 Richard L. Mueller\\nHilltop Lab web site - http://www.rlmueller.net\\nVersion 1.0 - January 2\\\, 2007\\nYou have a royalty-free right to use\\\, modify\\\, reproduce\\\, and\\ndistribute this script file in any way you find useful\\\, provided that\\nyou agree that the copyright owner above has no warranty\\\, obligations\\\,\\nor liability for such use.\\n------------------------------------------------------------------------\\n]]--\\nlocal lngX = 1000\\nlocal lngC = 48313\\n\\nlocal function _random(m\\\,n)\\n    local A_Hi = 63551\\n    local A_Lo = 25354\\n    local M = 4294967296\\n    local H = 65536\\n    \\n    function _MWC()\\n        local S_Hi = math.floor(lngX / H)\\n        local S_Lo = lngX - (S_Hi * H)\\n        local C_Hi = math.floor(lngC / H)\\n        local F1 = A_Hi * S_Hi\\n        local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi\\n     \\n        lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)\\n        lngX = lngX - (math.floor(lngX / M) * M)\\n        lngC = math.floor((F2 / H) + F1)\\n\\n        return lngX\\n    end\\n    \\n    if n == nil and m ~= nil then\\n        n = m\\n        m = 1\\n    end\\n    if (m == nil) and (n == nil) then\\n        return _MWC() / M\\n    else\\n        if n < m then\\n            return nil\\n        end\\n        return math.floor((_MWC() / M) * (n - m + 1)) + m\\n    end\\nend\\n\\nlocal function _abs(value)\\n    if value < 0 then\\n        return -value\\n    else\\n        return value\\n    end\\nend\\n\\nlocal function _floor(value)\\n    return value - (value % 1)\\nend\\n\\nlocal function _randomseed(s)\\n    if s==nil then \\n        s=math.abs(Score())\\n        if s==0 then s=get_score(true) end\\n        s=s%0.001\\n        s=1/s\\n        while s<100000 do s=s*1000 end\\n        s=s-s%1\\n    end\\n    lngX = s\\n    p(\\\"Random seed is \\\"..s)\\nend\\n\\nmath=\\n{\\n    abs = _abs\\\,\\n    floor = _floor\\\,\\n    random = _random\\\,\\n    randomseed = _randomseed\\\,\\n}\\nmath.randomseed()\\n--[[ End math library ]]--\\n\\nfunction SaveBest()\\n    local g=Score()-bestScore\\n    if g>0 then\\n        if g>0.01 then p(\\\"Gained another \\\"\\\,round(g)\\\,\\\" pts.\\\") end\\n        bestScore=Score()\\n        quicksave(3)\\n    end\\nend\\nfunction SaveRB()\\n    quicksave(4)\\n    restore_recent_best()\\n    SaveBest()\\n    quickload(4)\\nend\\n\\nfunction Qstab()\\n    select_all()\\n    CI(0.1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    if fastQstab==false then \\n        CI(0.4)\\n        Wiggle(\\\"wa\\\"\\\,1)\\n        CI(1)\\n        Wiggle(\\\"s\\\"\\\,1)\\n    end\\n    CI(1)\\n    Wiggle()\\nend\\n\\nfunction FuzeEnd()\\n    CI(1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    Wiggle()\\n    srb()\\nend\\nfunction Fuze1(ci1\\\,ci2)\\n    CI(ci1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\nend\\nfunction Fuze2(ci1\\\,ci2)\\n    CI(ci1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\nend\\nfunction srb()\\n    restore_recent_best()\\n    SaveBest()\\nend\\nfunction Fuze()\\n    p(\\\"Fuzing...\\\")\\n    local scr=Score()\\n    select_all()\\n    reset_recent_best()\\n    Fuze1(0.3\\\,0.6) FuzeEnd()\\n    Fuze2(0.3\\\,1) srb()\\n    Fuze1(0.05\\\,1) srb()\\n    Fuze2(0.7\\\,0.5) FuzeEnd()\\n    Fuze1(0.07\\\,1)\\n    srb()\\nend\\n\\nfunction random(n1\\\,n2) --random function returns int or float depends on input vars\\n    if n2==nil and n1==nil then\\n        return math.random() --float\\n    else\\n        if n2==nil then\\n            if n1%1==0 then\\n                return math.random(n1) --integer\\n            else\\n                return math.random()*n1 --float\\n            end\\n        else\\n            if n1%1==0 and n2%1==0 then\\n                return math.random(n1\\\,n2) --integer between \\n            else\\n                return math.random()*(n2-n1)+n1 --float between\\n            end\\n        end\\n    end\\nend\\n\\nfunction FillHerd() --fill up herd\\n    local n=\\\#critters\\n    if n>0 then --fill up\\n        n=herd.newRandom\\n    else --fresh herd\\n        n=herd.breedBest + herd.keepBest + herd.breedBastards \\n    end\\n    p(\\\"Randomizing \\\"..n..\\\" new critters...\\\")\\n    for i=1\\\,n do\\n        AddCritter()\\n    end\\nend\\nfunction AddCritter() --vreate new random critter\\n    local c={}\\n    critterID=critterID+1\\n    c.no=critterID\\n    c.name=c.no..'-rnd'\\n    c.bands={}\\n    local r=random(critter.minBands\\\, critter.maxBands)\\n    for i=1\\\,r do\\n        c.bands[\\\#c.bands+1]=AddBand()\\n    end\\n    critters[\\\#critters+1]=c\\n    p(c.name..\\\" bands: \\\"..\\\#c.bands)\\nend\\nfunction AddBand() --create one random band\\n    local cnt=0\\n    local b={}\\n    while true do --try till die\\n        cnt=cnt+1\\n        local s1=random(segCnt)\\n        local s2=random(segCnt)\\n        if s1>s2 then s1\\\,s2=s2\\\,s1 end --swap\\n        if CanBeUsed(s1\\\,s2) then\\n            local str=random(bands.minStr\\\,bands.maxStr)\\n            local len=0\\n            while true do --randomize corect distance\\n                len=random(-bands.maxDn\\\,bands.maxUp)\\n                if len<-bands.minChng or len>bands.minChng then break end\\n            end\\n            b={s1\\\,s2\\\,str\\\,len}\\n            break\\n        end\\n        \\n        if cnt>100 then\\n            p(\\\"Sorry! Cant create band! Breaking script!\\\")\\n            BreakScript() --there is no such function\\\, so it crashes script\\n        end\\n    end\\n    return b\\nend\\n\\nfunction CanBeUsed(sg1\\\,sg2) --checking end of bands\\n    function ssCheck(ss)\\n        local good=false\\n            if use.Sheet and ss==\\\"E\\\" then good=true end\\n            if use.Helix and ss==\\\"H\\\" then good=true end\\n            if use.Loop and ss==\\\"L\\\"  then good=true end\\n        return good\\n    end\\n    function AreGood(s1\\\,s2) --check that s1 and s2 can be used\\n\\t\\tlocal ok=true\\n\\t\\tif s2-s1<bands.minSkip then ok=false end\\n\\t\\tif ok==true and get_segment_distance(s1\\\,s2)<bands.minDist then ok=false end\\n\\t\\treturn ok \\n\\tend\\n\\t\\n    local ok=AreGood(sg1\\\,sg2)\\n    if ok==true and \\\#DoNotUse>0 then --none of 2 can be in that area\\n        for i=1\\\, \\\#DoNotUse do\\n            local r=DoNotUse[i]\\n            for x=r[1]\\\,r[2] do\\n                if x==sg1 or x==sg2 then\\n                    ok=false\\n                    break\\n                end\\n            end\\n            if ok==false then break end\\n        end\\n    end\\n    if ok==false then \\n        return false --if false can`t be used\\n    else\\n        ok=false\\n        if \\\#AlwaysUse>0 then --at least one have to be there\\n            for i=1\\\, \\\#AlwaysUse do\\n                local r=AlwaysUse[i]\\n                for x=r[1]\\\,r[2] do\\n                    if x==sg1 or x==sg2 then\\n                        ok=true\\n                        break\\n                    end\\n                end\\n                if ok==true then break end\\n            end\\n        else\\n            ok=true\\n        end\\n    end \\n    \\n    if ok==true then --check structure\\n        ok=false\\n        local ss1=get_ss(sg1)\\n        local ss2=get_ss(sg2)\\n        if checkBoth then\\n            if ssCheck(ss1) and ssCheck(ss2) then ok=true end\\n        else\\n            if ssCheck(ss1) or ssCheck(ss2) then ok=true end\\n        end\\n    end\\n    return ok\\nend\\n\\nfunction ScoreHerd() --score all critters from herd\\n    quickload(3)\\n    p(\\\"Scoring \\\"..\\\#critters..\\\" critters...\\\")\\n    quicksave(5)\\n    local herdScore=Score()\\n    for i=1\\\,\\\#critters do\\n        band_delete()\\n        local crt=critters[i] --critter\\n        local s=Score() --start score\\n        local bnds=crt.bands\\n        for b=1\\\,\\\#bnds do\\n            local bnd=bnds[b]\\n            band_add_segment_segment(bnd[1]\\\,bnd[2])\\n            local bc=get_band_count()\\n            band_set_strength(bc\\\,bnd[3])\\n            local len=get_segment_distance(bnd[1]\\\,bnd[2])+bnd[4]\\n            if len<bands.minLen then len=bands.minLen end\\n            band_set_length(bc\\\,len)\\n        end\\n        select_all()\\n        CI(pullCI)\\n        reset_recent_best()\\n        Wiggle(\\\"wb\\\"\\\,1)\\n        band_delete()\\n        CI(1)\\n        if s-Score() > qstabThresh then\\n            Qstab()\\n        else\\n            Wiggle()\\n        end\\n        if Score()-bestScore>fuzeThresh then \\n\\t\\t\\tSaveRB()\\n            Fuze() \\n        else\\n\\t\\t\\tSaveRB()\\n\\t\\tend\\n        \\n        crt.score=Score()-s\\n        p(\\\"Critter \\\"..crt.name..\\\" : \\\"..round(crt.score))\\n        \\n        if critter.maxLoss>0 then\\n            if Score()>herdScore-critter.maxLoss then\\n                quicksave(5)\\n                herdScore=Score()\\n            else\\n                quickload(5)\\n            end\\n        else\\n            quickload(3)\\n        end\\n    end\\n    quickload(3)\\n    if get_band_count()>0 then --clean bands from best solition (if any)\\n        band_delete()\\n        quicksave(3)\\n    end\\nend\\nfunction BreedCritters(mom\\\,dad\\\,t) --breed 2 critters. bands are taken randomly\\n    local kid={}\\n    critterID=critterID+1\\n    kid.no=critterID\\n    kid.name=kid.no..\\\"-\\\"..t..mom.no..'/'..dad.no\\n    kid.bands={}\\n\\tlocal mb=\\\#mom.bands\\n\\tlocal db=\\\#dad.bands\\n\\tif mb>db then mb\\\,db=db\\\,mb end --kid have bands count between mom and dad bands\\n    local bn=random(mb\\\,db)\\n    for i=1\\\,bn\\\,2 do\\n        kid.bands[\\\#kid.bands+1]=mom.bands[random(\\\#mom.bands)]\\n        kid.bands[\\\#kid.bands+1]=dad.bands[random(\\\#dad.bands)]\\n    end\\n    p(kid.name..\\\" bands: \\\"..\\\#kid.bands)\\n    return kid\\nend\\nfunction KeepGood() --copy best scoring critters form last gen if score above\\n    local newHerd={}\\n    for i=1\\\,herd.keepBest do\\n        if critters[i].score>critter.keepScore  and (math.abs(critters[i].score)>0.1 or critters[i].score>0) then\\n            newHerd[\\\#newHerd+1]=critters[i]\\n        end\\n    end\\n    return newHerd\\nend\\nfunction SortCritters() --bubble sort\\n    for i=1\\\,\\\#critters do\\n        for j=i+1\\\,\\\#critters do\\n            if critters[i].score<critters[j].score then\\n                critters[i]\\\,critters[j]=critters[j]\\\,critters[i] --love lua :)\\n            end\\n        end\\n    end\\nend\\nfunction BreedHerd()\\n    p(\\\"Breeding...\\\")\\n    SortCritters()\\n    newHerd=KeepGood()\\n    for i=1\\\, herd.breedBest do\\n        local mom=critters[i]\\n        if mom.score>critter.breedScore or i<2 then --breed only good ones\\\, 1st is always breed anyway\\n            for j=i+1\\\, herd.breedBest do\\n                local dad=critters[j]\\n                newHerd[\\\#newHerd+1]=BreedCritters(mom\\\,dad\\\,\\\"kid-\\\")\\n\\t\\t\\t\\tnewHerd[\\\#newHerd+1]=BreedCritters(dad\\\,mom\\\,\\\"kid-\\\")\\n            end\\n        end\\n    end\\n    for i=1\\\, herd.breedBastards do --they will always appear ;]\\n        local mom=critters[i]\\n        local j=random(herd.breedBastards+1\\\,\\\#critters)\\n        local dad=critters[j]\\n        newHerd[\\\#newHerd+1]=BreedCritters(mom\\\,dad\\\,\\\"bas-\\\")\\n\\t\\tnewHerd[\\\#newHerd+1]=BreedCritters(dad\\\,mom\\\,\\\"bas-\\\")\\n    end\\n    critters=newHerd\\n    FillHerd()\\nend\\nfunction ShuffleHerd()\\n    if herd.shuffle==true then \\n        for i=1\\\,\\\#critters do\\n            local r=random(\\\#critters)\\n            if r~=i then\\n                critters[i]\\\,critters[r]=critters[r]\\\,critters[i]\\n            end\\n        end\\n    end\\nend\\nfunction GAB()\\n    bestScore=Score()\\n    critterID=0\\n    gen=0\\n    ss=Score()\\n    quicksave(3)\\n    reset_recent_best()\\n    p(\\\"Starting Rav3n_pl GAB v0.4.2 Start score: \\\"..round(ss))\\n    critters={}\\n    FillHerd()\\n    badGen=0\\n    while true do --this is (almost) endless script ;]\\n        genScore=Score()\\n\\t\\tgen=gen+1\\n        p()\\n        p(\\\"Generation: \\\"..gen..\\\"\\\, score: \\\"..round(Score())..\\\"\\\, gain: \\\"..round(Score()-ss))\\n        ShuffleHerd()\\n        ScoreHerd()\\n        quickload(3)\\n\\t\\tif gen==herd.maxGen then break end --end of script\\n\\t\\t\\n\\t\\tif genScore>=Score() then badGen=badGen+1 else badGen=0 end\\n\\t\\tif badGen>=herd.renew then \\n\\t\\t\\tp(\\\"Creating fresh random herd...\\\")\\n\\t\\t\\tcritters={}\\n\\t\\t\\tFillHerd()\\n\\t\\t\\tbadGen=0\\n\\t\\telse\\n\\t\\t\\tBreedHerd()\\n\\t\\tend\\n    end\\n    p(\\\"Final score: \\\"..round(Score())..\\\" Total gain: \\\"..round(Score()-ss))\\nend\\n\\n-- main call\\nGAB()\\n\\n\\n\\n--end of script\"\n \"script_version\" : \"1\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"8\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_326559639" : "{\n \"desc\" : \"Freeze all beta strand SS\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"FREEZE_STRANDS - SG\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"0\"\n \"script\" : \"-- freeze-STRANDS-SG --\\nfunction _main_()\\n  local k = structure.GetCount()\\n  local get_ss = structure.GetSecondaryStructure\\n  local BETA_STRAND = 'E'\\n  local freeze_backbone = true\\n  local freeze_sidechain = false\\n  print('FREEZE_SS-H Recipe\\\\nworking ..')\\n  selection.DeselectAll()\\n  for i=1\\\,k do\\n    if get_ss(i) == BETA_STRAND then\\n      selection.Select(i)\\n    end\\n  end -- loopf\\n  if selection.GetCount() then\\n    freeze.FreezeSelected(freeze_backbone\\\,freeze_sidechian)\\n    selection.DeselectAll()\\n  end\\n  print('..Done.')\\nend\\n\\nxpcall(_main_\\\,absolutebest.Restore)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1879647968\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_507689389" : "{\n \"desc\" : \"Freeze SS\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"FREEZE SS\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"0\"\n \"script\" : \"local j = structure.GetCount()\\nfor i=1\\\,j do\\n    if structure.GetSecondaryStructure(i) ~= 'L' then\\n      freeze.Freeze(i\\\,true\\\,false)\\n    end\\nend\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"94208\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_564102868" : "{\n \"desc\" : \"perform walkthrough sh for all segments\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"SHK-SG\"\n \"parent\" : \"101706\"\n \"parent_mrid\" : \"202322\"\n \"player_id\" : \"0\"\n \"script\" : \"-- SHK-SG --\\nfunction _main_()\\n  local k = structure.GetCount()\\n  local iters = 1\\n  local s_0 = current.GetScore()\\n  local s_1 = current.GetScore()\\n  recentbest.Save()\\n  print('SHK-SG recipe\\\\nScore: '..s_0)\\n  for i=1\\\,k do\\n    selection.DeselectAll()\\n    selection.Select(i)\\n    structure.ShakeSidechainsSelected(iters)\\n    recentbest.Restore()\\n    s_1 = current.GetScore()\\n    if (s_1-s_0)>0.001 then\\n      local gain_found = true\\n      while(gain_found) do\\n        structure.WiggleAll(1)\\n        gain_found = current.GetScore()>s_1+1\\n        s_1 = current.getScore()\\n      end\\n      print('Segment '..i..'\\\\n')\\n      print('Gain found: '..s_1\\\,' +'..(s_1-s_0)..'\\\\n')\\n      s_0 = s_1\\n    end\\n  end--loopf\\nend\\n\\nxpcall(_main_\\\,absolutebest.Restore)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_711541113" : "{\n \"desc\" : \"RB on segments by SS\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"101704\"\n \"mrid\" : \"202320\"\n \"name\" : \"RB - SG\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"199249\"\n \"script\" : \"-- LWS-SG --\\nfunction _main_()\\nlocal stride = 2\\nlocal boost = 2\\nlocal k = structure.GetCount()-stride\\nlocal segs = structure.GetCount()\\nlocal s_0 = current.GetScore()\\nlocal s_1 = current.GetScore()\\nlocal maxstride = 8\\nlocal iters = 1\\nlocal start = 1\\nlocal spread = 2\\nlocal thresh = 0.001\\nlocal next_i = 1\\nlocal next_ss = structure.GetSecondaryStructure(1)\\nprint('SSRB-SG script\\\\nSegments: '..segs..'\\\\n')\\nrecentbest.Save()\\nselection.DeselectAll()\\nprint('Score: '..s_0..'\\\\n')\\nwhile(1) do\\nfor i=start\\\,k do\\n  local ss = structure.GetSecondaryStructure(i)\\n  if ss == next_ss then\\n    selection.Select(i)\\n  else\\n    structure.RebuildSelected(iters)\\n    --behavior.SetClashImportance(0.1)\\n    --structure.ShakeSidechainsSelected(iters)--\\n    --behavior.SetClashImportance(1)--\\n    --structure.WiggleSelected(iters\\\,true\\\,false)--\\n    structure.WiggleAll(iters)--Selected(iters+spread)--\\n    --behavior.SetClashImportance(1)--\\n    --structure.WiggleAll(iters)--\\n    recentbest.Restore()\\n    s_1 = current.GetScore()\\n    if (s_1-s_0)>thresh then\\n      print('Segments '..next_i..' - '..i)\\n      print('Gain found: '..s_1\\\,' +'..(s_1-s_0)..'\\\\n')\\n      s_0 = s_1\\n    end\\n    selection.DeselectAll()\\n    selection.Select(i)\\n    next_ss = ss\\n    next_i = i\\n  end\\nend--loopf\\nend--loopw\\nend--func\\n\\nxpcall(_main_\\\,absolutebest.Restore)\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"1\"\n \"type\" : \"script\"\n \"uses\" : \"1\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_724153811" : "{\n \"desc\" : \"GAB Loss 0.6 with minimum global ops. Press Ctl+N to restore best.\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"0\"\n \"mrid\" : \"0\"\n \"name\" : \"XBander\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"0\"\n \"script\" : \"--[[\\nXBander\\nby Seagat2011\\nbased on GAB - Genetic Algorithm on Bands\\nby Rav3n_pl\\nbased on CartoonVillan and Crashguard303 scripts\\n\\nDefinitions:\\nband: randomised: start segment\\\, end segment\\\, length\\\, strength\\ncritter: set of bands\\nherd: set of critters\\n\\n1.\\n- randomize needed bands \\n- randomly assignig them to criters\\n\\n2.\\n- score each critter\\n\\n3.\\n- keep critters scoring above score\\n- breed best critters\\n- breed bastards (best one + random one)\\n- forget about rest of critter\\n- randomize new critters to fill herd\\n\\n4.\\n- GAB Loss 0.6 with minimum global ops. Press Ctl+N to restore best.\\n\\n]]--\\n\\nlocal ver = 1.9\\n\\n-- options:\\nenergy=false --set true to seek energy in exploration puzzles; false works on all puzzles\\npullCI=0.9 --Clash Impotrance during pull\\nfastQstab=true--true -- only 1ong SH 1ong WA after pull if true\\nfuzeThresh = 1 -- run fuze if we are close to best score (negative=new best score)\\nqstabThresh=30--10 -- run qstab if score drops more than... wiggle only in other case\\nmaxCI=1 --changle to lower if not want tu use c=1 shake/wiggle at all. good in eraly game\\n\\nherd= --herd options\\n{ \\nbreedBest = 0\\\,--5\\\, --breed best 4 critters - all combinations => 6 kids form 4 critters\\\, 3 form 3\\\, 1 form 2\\\, 9 form 5 ;]\\nkeepBest = 3\\\, --save up to 3 best scoring critters\\\, rest are forgotten\\nbreedBastards = 0\\\,--8\\\, --number of best will have one random bastard\\nnewRandom = 200\\\, --adding new random ones each generation\\nmaxGen = 200\\\, --maximum generations \\nshuffle =  true\\\, --set true to run critters in random order\\nrenew=4\\\, --create totally fresh herd after that many gens w/o improvement\\n}\\ncritter= --critter options\\n{\\nminBands=1\\\, --minimum bands\\nmaxBands=4\\\,--7\\\, --maximum bands\\nkeepScore = 0.1 \\\, --survive to next gen only if score higher than\\nbreedScore=-20\\\, --will breed kids only if score higher. Basttards always breed\\nmaxLoss=30\\\, --maximum loss by critter. set 0 to disable\\n}\\n\\nbands= --bands options\\n{\\nminStr=0.3\\\, --minimum band str\\nmaxStr=1.1\\\, --maximum band str\\nminChng = 3\\\, -- minimum change of band len accordig to current distance\\nmaxUp = 7.1\\\, -- maximum change up (push)\\nmaxDn = 7.9\\\, -- maximum change down (pull)\\nminSkip = 10\\\, --minimum segment distance\\nminDist = 4\\\, --minimum spatial distance\\nminLen = 2\\\, --minimum lenght of created band\\n}\\n\\nDoNotUse={--just comment lines below or add more areas to avoid\\n--{segCnt\\\,segCnt}\\\, --ligand cant be used\\n--{120\\\,134}\\\,\\n--{1\\\,10}\\\,\\n}\\nAlwaysUse={ --areas should be always used\\n--{segCnt\\\,segCnt}\\\,--ligand need to be at one end\\n--{308\\\,311}\\\, --loopy\\n--{272\\\,319}\\\, --loopy\\n}\\n\\n-- bands by secondary structure\\nuse=\\n{\\nSheet=true\\\, --set false to not band sheets\\nHelix=true\\\, --set false to not band helices\\nLoop=true\\\, --set false to not band loops\\n}\\ncheckBoth=false --check both ends to above\\\, if false only one end need to be true\\n\\n--end of options\\n\\nsegCnt=structure.GetCount()\\np=print\\nfunction CI(c)\\nif c>maxCI then c=maxCI end\\nbehavior.SetClashImportance(c)\\nend\\nfunction round(x)--cut all afer 3-rd place\\n    return x-x%0.001\\nend\\nfunction down(x)\\n    return x-x%1\\nend\\nfunction Score()--return score\\\, exploration too\\n    if energy==true then\\n        return current.GetScore()\\n    else\\n        return current.GetEnergyScore()\\n    end\\nend \\nfunction SmartWiggle(how\\\,iters\\\,minppi)\\n    local _minppi_ = minppi\\n    local _iters__ = iters\\n    if _minppi_ == nil then _minppi_ = 1 end\\n    if _iters_ == nil then _iters_ = 1 end\\n    local op = {\\n        wb = function(w)\\n          local wiggle_backbone = structure.WiggleAll\\n          wiggle_backbone(w\\\,true\\\,false)\\n          end\\\,\\n        ws = function(w)\\n          local wiggle_sidechains = structure.WiggleAll\\n          wiggle_sidechains(w\\\,false\\\,true)\\n          end\\\,\\n        wa = function(w)\\n          structure.WiggleAll(w)\\n          end\\\,\\n    }\\n    local gain_found = true\\n    while (gain_found) do\\n      local s_0 = current.GetScore()\\n      if op[how] then\\n        op[how](_iters_)\\n      else\\n        op.wa(_iters_)\\n      end\\n      gain_found = current.GetScore() > s_0+_minppi_\\n    end\\nend\\nfunction Wiggle(how\\\, iters\\\, minppi)\\n    if how==nil then how=\\\"wa\\\" end\\n    if iters==nil then iters=6 end\\n    if minppi==nil then minppi=0.1 end\\n    if iters>0 then\\n        iters=iters-1\\n        sp=Score()\\n        if how == \\\"s\\\" then structure.ShakeSidechainsAll(1)\\n            elseif how == \\\"wb\\\" then structure.WiggleAll(2\\\,true\\\,false)\\n            elseif how == \\\"ws\\\" then structure.WiggleAll(2\\\,false\\\,true)\\n            elseif how == \\\"wa\\\" then structure.WiggleAll(2) \\n        end\\n        ep = Score()\\n        ig=ep-sp\\n        if how~=\\\"s\\\" then\\n            if ig > minppi then return Wiggle(how\\\, iters\\\, minppi) end --tail call\\n        end\\n    end\\nend\\n\\n--[[\\nTlaloc`s math library\\n------------------------------------------------------------------------\\nThe original random script this was ported from has the following notices:\\nCopyright (c) 2007 Richard L. Mueller\\nHilltop Lab web site - http://www.rlmueller.net\\nVersion 1.0 - January 2\\\, 2007\\nYou have a royalty-free right to use\\\, modify\\\, reproduce\\\, and\\ndistribute this script file in any way you find useful\\\, provided that\\nyou agree that the copyright owner above has no warranty\\\, obligations\\\,\\nor liability for such use.\\n------------------------------------------------------------------------\\n]]--\\nlocal lngX = 1000\\nlocal lngC = 48313\\nlocal function _random(m\\\,n)\\n    local A_Hi = 63551\\n    local A_Lo = 25354\\n    local M = 4294967296\\n    local H = 65536\\n    \\n    function _MWC()\\n        local S_Hi = math.floor(lngX / H)\\n        local S_Lo = lngX - (S_Hi * H)\\n        local C_Hi = math.floor(lngC / H)\\n        local F1 = A_Hi * S_Hi\\n        local F2 = (A_Hi * S_Lo) + (A_Lo * S_Hi) + C_Hi\\n     \\n        lngX = ((F2 - (math.floor(F2 / H) * H)) * H) + (A_Lo * S_Lo) + lngC - (C_Hi * H)\\n        lngX = lngX - (math.floor(lngX / M) * M)\\n        lngC = math.floor((F2 / H) + F1)\\n\\n        return lngX\\n    end\\n    \\n    if n == nil and m ~= nil then\\n        n = m\\n        m = 1\\n    end\\n    if (m == nil) and (n == nil) then\\n        return _MWC() / M\\n    else\\n        if n < m then\\n            return nil\\n        end\\n        return math.floor((_MWC() / M) * (n - m + 1)) + m\\n    end\\nend\\nlocal function _abs(value)\\n    if value < 0 then\\n        return -value\\n    else\\n        return value\\n    end\\nend\\nlocal function _floor(value)\\n    return value - (value % 1)\\nend\\nlocal function _randomseed(s)\\n    local f = recipe.GetRandomSeed\\n    if s==nil then \\n        s=math.abs(f())--math.abs(Score())\\n        while s==0 do s=math.abs(f()) end\\n        --s=s%0.001\\n        --s=1/s\\n        while s<100000 do s=s*1000 end\\n        s=s-s%1\\n    end\\n    lngX = s\\n    p(\\\"Random seed is \\\"..s)\\nend\\n\\nmath=\\n{\\n    abs = _abs\\\,\\n    floor = _floor\\\,\\n    random = _random\\\,\\n    randomseed = _randomseed\\\,\\n}\\nmath.randomseed()\\n--[[ End math library ]]--\\n\\nfunction SaveBest()\\n    local g=Score()-bestScore\\n    if g>0 then\\n        if g>0.01 then p(round(Score())\\\,\\\"Gained another \\\"\\\,round(g)\\\,\\\" pts.\\\") end\\n        bestScore=Score()\\n        save.Quicksave(3)\\n    end\\nend\\nfunction Qstab()\\n    selection.SelectAll()\\n    CI(pullCI)--(0.1)\\n    local s_0 = Score()\\n    Wiggle(\\\"s\\\"\\\,1)\\n    if Score()-s_0 < 0.001 then\\n        Wiggle(\\\"ws\\\"\\\,1)\\n    end\\n    if fastQstab==false then \\n        CI(0.4)\\n        Wiggle(\\\"wa\\\"\\\,1)\\n        CI(1)\\n        Wiggle(\\\"s\\\"\\\,1)\\n    end\\n    CI(1)\\n    Wiggle()\\nend\\nfunction FuzeEnd()\\n    CI(1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    Wiggle()\\nend\\nfunction Fuze1(ci1\\\,ci2)\\n    CI(ci1)\\n    Wiggle(\\\"wb\\\"\\\,1)\\n    CI(1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(ci1)\\n    Wiggle(\\\"s\\\"\\\,1)\\n    Wiggle(\\\"wb\\\"\\\,1)\\n    CI(1)\\n    Wiggle(\\\"wb\\\"\\\,1)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\nend\\nfunction Fuze2(ci1\\\,ci2)\\n    CI(ci1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(1)\\n    Wiggle(\\\"wa\\\"\\\,1)\\n    CI(ci2)\\n    Wiggle(\\\"wa\\\"\\\,1)\\nend\\nfunction srb()\\n    recentbest.Restore()\\n    --SaveBest()\\nend\\nfunction Fuze()\\n    p(\\\"Fuzing...\\\")\\n    local scr=Score()\\n    selection.SelectAll()\\n    --recentbest.Save()\\n    Fuze1(0.3\\\,0.6) FuzeEnd()\\n    Fuze2(0.3\\\,1) --srb()\\n    Fuze1(0.05\\\,1) --srb()\\n    Fuze2(0.7\\\,0.5) FuzeEnd()\\n    Fuze1(0.07\\\,1)\\n    srb()\\nend\\n\\nfunction random(n1\\\,n2) --random function returns int or float depends on input vars\\n    if n2==nil and n1==nil then\\n        return math.random() --float\\n    else\\n        if n2==nil then\\n            if n1%1==0 then\\n                return math.random(n1) --integer\\n            else\\n                return math.random()*n1 --float\\n            end\\n        else\\n            if n1%1==0 and n2%1==0 then\\n                return math.random(n1\\\,n2) --integer between \\n            else\\n                return math.random()*(n2-n1)+n1 --float between\\n            end\\n        end\\n    end\\nend\\n\\nfunction FillHerd() --fill up herd\\n    local n=\\\#critters\\n    if n>0 then --fill up\\n        n=herd.newRandom\\n    else --fresh herd\\n        n=herd.breedBest + herd.keepBest + herd.breedBastards \\n    end\\n    p(\\\"Randomizing \\\"..n..\\\" new critters...\\\")\\n    for i=1\\\,n do\\n        AddCritter()\\n    end\\nend\\nfunction AddCritter() --vreate new random critter\\n    local c={}\\n    critterID=critterID+1\\n    c.no=critterID\\n    c.name=c.no..'-rnd'\\n    c.bands={}\\n    local r=random(critter.minBands\\\, critter.maxBands)\\n    for i=1\\\,r do\\n        c.bands[\\\#c.bands+1]=AddBand()\\n    end\\n    critters[\\\#critters+1]=c\\n    p(c.name..\\\" bands: \\\"..\\\#c.bands)\\nend\\nfunction AddBand() --create one random band\\n    local cnt=0\\n    local b={}\\n    while true do --try till die\\n        cnt=cnt+1\\n        local s1=random(segCnt)\\n        local s2=random(segCnt)\\n        if s1>s2 then s1\\\,s2=s2\\\,s1 end --swap\\n        if CanBeUsed(s1\\\,s2) then\\n            local str=random(bands.minStr\\\,bands.maxStr)\\n            local len=0\\n            while true do --randomize corect distance\\n                len=random(-bands.maxDn\\\,bands.maxUp)\\n                if len<-bands.minChng or len>bands.minChng then break end\\n            end\\n            b={s1\\\,s2\\\,str\\\,len}\\n            break\\n        end\\n        if cnt>100 then\\n            p(\\\"Sorry! Cant create band! Breaking script!\\\")\\n            BreakScript() --there is no such function\\\, so it crashes script\\n        end\\n    end\\n    return b\\nend\\n\\nfunction CanBeUsed(sg1\\\,sg2) --checking end of bands\\n    function ssCheck(ss)\\n        local good=false\\n            if use.Sheet and ss==\\\"E\\\" then good=true end\\n            if use.Helix and ss==\\\"H\\\" then good=true end\\n            if use.Loop and ss==\\\"L\\\"  then good=true end\\n        return good\\n    end\\n    function AreGood(s1\\\,s2) --check that s1 and s2 can be used\\n      local ok=true\\n      if s2-s1<bands.minSkip then ok=false end\\n      if ok==true and structure.GetDistance(s1\\\,s2)<bands.minDist then ok=false end\\n      return ok \\n    end\\n    local ok=AreGood(sg1\\\,sg2)\\n    if ok==true and \\\#DoNotUse>0 then --none of 2 can be in that area\\n        for i=1\\\, \\\#DoNotUse do\\n            local r=DoNotUse[i]\\n            for x=r[1]\\\,r[2] do\\n                if x==sg1 or x==sg2 then\\n                    ok=false\\n                    break\\n                end\\n            end\\n            if ok==false then break end\\n        end\\n    end\\n    if ok==false then \\n        return false --if false can`t be used\\n    else\\n        ok=false\\n        if \\\#AlwaysUse>0 then --at least one have to be there\\n            for i=1\\\, \\\#AlwaysUse do\\n                local r=AlwaysUse[i]\\n                for x=r[1]\\\,r[2] do\\n                    if x==sg1 or x==sg2 then\\n                        ok=true\\n                        break\\n                    end\\n                end\\n                if ok==true then break end\\n            end\\n        else\\n            ok=true\\n        end\\n    end \\n    if ok==true then --check structure\\n        ok=false\\n        local ss1=structure.GetSecondaryStructure(sg1)\\n        local ss2=structure.GetSecondaryStructure(sg2)\\n        if checkBoth then\\n            if ssCheck(ss1) and ssCheck(ss2) then ok=true end\\n        else\\n            if ssCheck(ss1) or ssCheck(ss2) then ok=true end\\n        end\\n    end\\n    return ok\\nend\\n\\nfunction ScoreHerd() --score all critters from herd\\n    p(\\\"Scoring \\\"..\\\#critters..\\\" critters...\\\")\\n    local herdScore=Score()\\n    for i=1\\\,\\\#critters do\\n        --recentbest.Restore()\\n        band.DeleteAll()\\n        local crt=critters[i] --critter\\n        local s=Score() --start score\\n        local bnds=crt.bands\\n        for b=1\\\,\\\#bnds do\\n            local bnd=bnds[b]\\n            band.AddBetweenSegments(bnd[1]\\\,bnd[2])\\n            local bc=band.GetCount()\\n            band.SetStrength(bc\\\,bnd[3])\\n            local len=structure.GetDistance(bnd[1]\\\,bnd[2])+bnd[4]\\n            if len<bands.minLen then len=bands.minLen end\\n            band.SetGoalLength(bc\\\,len)\\n        end\\n        selection.SelectAll()\\n        CI(pullCI)\\n            Wiggle(\\\"wb\\\"\\\,1)\\n            band.DisableAll()\\n            CI(1)\\n            Wiggle(\\\"s\\\"\\\,1)\\n            ui.CenterViewport()\\n            SmartWiggle(\\\"wb\\\"\\\,1)\\n            band.EnableAll()\\n        CI(pullCI)\\n            Wiggle(\\\"wb\\\"\\\,1)\\n            band.DeleteAll()\\n            CI(1)\\n            ui.CenterViewport()\\n            SmartWiggle(\\\"wa\\\"\\\,1)\\n        local incr = ''\\n        local gain = Score()>bestScore\\n        crt.score=Score()-s\\n        if gain then \\n          Fuze()\\n          incr = '+'..round(Score()-bestScore)\\n          bestScore = Score()\\n          gain = '  ( '..round(Score())..' )\\\, Total:  +'..round(Score()-ss)..'  ( '..round(ss)..' ) ' \\n          recentbest.Save()\\n        else\\n          incr = round(crt.score)\\n          gain = ''\\n        end\\n        p(\\\"Critter \\\"..crt.name..\\\" : \\\"..incr..gain)\\n        if critter.maxLoss>0 then\\n            if critter.maxLoss<crt.score then\\n               herdScore=Score()\\n            end\\n            if Score()+critter.maxLoss<bestScore then\\n                recentbest.Restore()\\n            end\\n        end\\n    end\\n    --recentbest.Restore()\\n    if band.GetCount() then --clean bands from best sol'n (iff any)\\n        band.DeleteAll()\\n        recentbest.Save()\\n    end\\nend\\nfunction BreedCritters(mom\\\,dad\\\,t) --breed 2 critters. bands are taken randomly\\n    local kid={}\\n    critterID=critterID+1\\n    kid.no=critterID\\n    kid.name=kid.no..\\\"-\\\"..t..mom.no..'/'..dad.no\\n    kid.bands={}\\n local mb=\\\#mom.bands\\n local db=\\\#dad.bands\\n if mb>db then mb\\\,db=db\\\,mb end --kid have bands count between mom and dad bands\\n    local bn=random(mb\\\,db)\\n    for i=1\\\,bn\\\,2 do\\n        kid.bands[\\\#kid.bands+1]=mom.bands[random(\\\#mom.bands)]\\n        kid.bands[\\\#kid.bands+1]=dad.bands[random(\\\#dad.bands)]\\n    end\\n    p(kid.name..\\\" bands: \\\"..\\\#kid.bands)\\n    return kid\\nend\\nfunction KeepGood() --copy best scoring critters form last gen if score above\\n    local newHerd={}\\n    for i=1\\\,herd.keepBest do\\n        if critters[i].score>critter.keepScore  and (math.abs(critters[i].score)>0.1 or critters[i].score>0) then\\n            newHerd[\\\#newHerd+1]=critters[i]\\n        end\\n    end\\n    return newHerd\\nend\\nfunction SortCritters() --bubble sort\\n    for i=1\\\,\\\#critters do\\n        for j=i+1\\\,\\\#critters do\\n            if critters[i].score<critters[j].score then\\n                critters[i]\\\,critters[j]=critters[j]\\\,critters[i] --love lua :)\\n            end\\n        end\\n    end\\nend\\nfunction BreedHerd()\\n    p(\\\"Breeding...\\\")\\n    SortCritters()\\n    newHerd=KeepGood()\\n    for i=1\\\, herd.breedBest do\\n        local mom=critters[i]\\n        if mom.score>critter.breedScore or i<2 then --breed only good ones\\\, 1st is always breed anyway\\n            for j=i+1\\\, herd.breedBest do\\n                local dad=critters[j]\\n                newHerd[\\\#newHerd+1]=BreedCritters(mom\\\,dad\\\,\\\"kid-\\\")\\n                newHerd[\\\#newHerd+1]=BreedCritters(dad\\\,mom\\\,\\\"kid-\\\")\\n            end\\n        end\\n    end\\n    for i=1\\\, herd.breedBastards do --they will always appear ;]\\n        local mom=critters[i]\\n        local j=random(herd.breedBastards+1\\\,\\\#critters)\\n        local dad=critters[j]\\n        newHerd[\\\#newHerd+1]=BreedCritters(mom\\\,dad\\\,\\\"bastard-\\\")\\n        newHerd[\\\#newHerd+1]=BreedCritters(dad\\\,mom\\\,\\\"bastard-\\\")\\n    end\\n    critters=newHerd\\n    FillHerd()\\nend\\nfunction ShuffleHerd()\\n    if herd.shuffle==true then \\n        for i=1\\\,\\\#critters do\\n            local r=random(\\\#critters)\\n            if r~=i then\\n                critters[i]\\\,critters[r]=critters[r]\\\,critters[i]\\n            end\\n        end\\n    end\\nend\\nfunction GAB()\\n    bestScore=Score()\\n    critterID=0\\n    gen=0\\n    ss=Score()\\n    save.Quicksave(3)\\n    recentbest.Save()\\n    p(\\\"Starting XBander v\\\"..ver..\\\" - Seagat2011 recipe\\\\nStart score: \\\"..round(ss))\\n    critters={}\\n    FillHerd()\\n    badGen=0\\n    while true do --this is (almost) endless script ;]\\n        genScore=Score()\\n        gen=gen+1\\n        p()\\n        p(\\\"Generation: \\\"..gen..\\\"\\\, score: \\\"..round(bestScore)..\\\"\\\, gain: \\\"..round(bestScore-ss))\\n        ShuffleHerd()\\n        ScoreHerd()\\n        save.Quickload(3)\\n        if gen==herd.maxGen then break end --end of script\\n        if genScore>=Score() then badGen=badGen+1 else badGen=0 end\\n        if badGen>=herd.renew then \\n            p(\\\"Creating fresh random herd...\\\")\\n            critters={}\\n            FillHerd()\\n            badGen=0\\n        else\\n            BreedHerd()\\n        end\\n    end\\n    p(\\\"Final score: \\\"..round(Score())..\\\" Total gain: \\\"..round(Score()-ss))\\nend\\n\\n-- main call\\nGAB()--xpcall(GAB\\\,absolutebest.Restore)\\n--end of script\\n\\n\\n\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"94208\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_799213114" : "{\n \"desc\" : \"Pre year 2013 recipes run well in foldit but then break when you try to edit them. This is because their APIs are out of date. This recipe Upgrades all version-1 APIs to optional version-2 or to more powerful\\\, fully compatible version-3. Recipes are saved to scriptlog.default.xml or your scriptlog.[current_track].xml and should be imported into a \\\"version-2\\\" or greater environment.  \"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"0\"\n \"mid\" : \"100691\"\n \"mrid\" : \"200951\"\n \"name\" : \"(FOLDIT) Classic-Recipe API Upgrade Tool (V1 to V2)\"\n \"parent\" : \"100644\"\n \"parent_mrid\" : \"200874\"\n \"player_id\" : \"199249\"\n \"script\" : \"--[[------------------------------------------------------------------------------------------------\\n\\nFOLDIT API (Classic Recipe) UPGRADE TOOL - recipe - v1.0 -- Upgrades Classic foldit recipes (ie. API version-1) to run in version-2 environment. \\n    Recipe Upgrades version-1 APIs to version-2 or to more powerful\\\, fully compatible version-3.\\n    \\n    Copyright (C) 2015 Seagat2011 <http://fold.it/port/user/1992490>\\n\\n    This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation\\\, either version 3 of the License\\\, or\\n    (at your option) any later version.\\n\\n    This program is distributed in the hope that it will be useful\\\,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n    You should have received a copy of the GNU General Public License\\n    along with this program.  If not\\\, see <http://www.gnu.org/licenses/>.\\n\\n------------------------------------------------------------------------------------------------]]--\\n--[[\\n\\nv1.0\\n- inception\\n\\n__import ( FOLDIT_API_UPGRADE_TOOL.js )\\n\\n]]--\\n\\nlocal g_Commandline \\nlocal g_version = '1.0'\\nlocal g_author  = 'Author: Seagat2011 - '..os.date('%c')\\n\\nprint ( '\\\\n' )\\n--print ('(FOLDIT) API Upgrade Tool v'..g_version)\\n--print ( g_author )\\n\\nlocal str  = 'Anthropic Dreams Solution - ref\\\#:'..puzzle.GetExpirationTime ()..user.GetPlayerID ()\\ng_author = g_author .. ' -- ' .. str\\nlocal return_value = {\\n  OK     = 1\\\,\\n  HELP   = 2\\\,\\n  CANCEL = 0\\n}\\nlocal status = 0\\n\\nlocal API_VERSION = { -- Application-Programmer Interface (version)\\n  ONE   = 1\\\,\\n  TWO   = 2\\\,\\n  THREE = 3\\\,\\n}\\n\\n\\nlocal ask    = dialog.CreateDialog ( \\\"Anthropic Dreams - API Upgrade Tool v\\\"..g_version )\\nask.spacer01 = dialog.AddLabel  ( \\\"Select target API version. ( if any )\\\" )\\n--[[\\nask.spacer02 = dialog.AddLabel ( '' )\\nask.spacer03 = dialog.AddLabel ( '' )\\nask.spacer04 = dialog.AddLabel ( '' )\\nask.spacer05 = dialog.AddLabel ( '' )\\nask.spacer06 = dialog.AddLabel ( '' )\\nask.spacer07 = dialog.AddLabel ( '' )\\nask.spacer08 = dialog.AddLabel ( '' )\\nask.spacer09 = dialog.AddLabel ( '' )]]--\\nask.spacer10 = dialog.AddLabel ( 'API version' )\\nask.slider11 = dialog.AddSlider ( ''\\\,2\\\,1\\\,3\\\,0 )\\nask.spacer12 = dialog.AddLabel ( '' )\\n--ask.spacer13 = dialog.AddLabel ( 'Paste recipe into window below..' )\\nask.spacer14 = dialog.AddLabel ( '' )\\nask.srcCode  = dialog.AddTextbox ( 'Paste recipe(s)'\\\,'' )\\nask.spacer15 = dialog.AddLabel ( '' )\\nask.OK       = dialog.AddButton(\\\"OK\\\"\\\,1)\\nask.HELP     = dialog.AddButton(\\\"HELP\\\"\\\,2)\\n\\n\\nlocal askhelp    = dialog.CreateDialog ( 'Anthropic Dreams - Help Window ' )\\naskhelp.spacer01 = dialog.AddLabel ( '' )\\naskhelp.spacer02 = dialog.AddLabel ( '' )\\naskhelp.spacer03 = dialog.AddLabel ( '' )\\naskhelp.spacer04 = dialog.AddLabel ( '' )\\naskhelp.spacer05 = dialog.AddLabel ( [[ API Version:  \\n\\n - version 1. (Do not update / No change)\\n - version 2. (Optimize file size) *\\n - version 3. (Most compatible) \\n\\n * - default setting ]] )\\n\\naskhelp.spacer06 = dialog.AddLabel ( '' )\\naskhelp.spacer07 = dialog.AddLabel ( '' )\\naskhelp.spacer08 = dialog.AddLabel ( '' )\\naskhelp.spacer09 = dialog.AddLabel ( '' )\\naskhelp.OK = dialog.AddButton ( \\\"OK\\\"\\\,1 )\\n\\nstatus = dialog.Show ( ask )\\nwhile ( status == return_value.HELP ) do\\n  dialog.Show ( askhelp )\\n  status = dialog.Show ( ask ) \\nend\\n\\n--[[-------OBJECT-------------\\nDescription: Lua-equivalent SELECT-statement\\n\\n1.\\nlocal choice = { -- codebody --\\n  [2] = 'First value!'\\\,\\n  [10] = 'Success!'\\\,\\n  ['default'] = 'Oops! Try again!'\\\, *** required! *** --\\n} -- code --\\nlocal data = 9\\nlocal Statement = g_Select.New()\\nStatement:Select (data\\\,choice) ()\\nprint(Statement.result)\\n\\n2.\\nlocal choice = { -- codebody --\\n  [2]  = function ( ... ) \\n    local this = arg[1]\\n    return 'First value!'\\n    end\\\,\\n  [10] = function ( ... ) \\n    local this = arg[1]\\n    print ( 'Success!' )\\n    return 1 -- must return a value! --\\n    end\\\,\\n  ['default'] = function ( ... ) -- *** required! *** -- \\n    local this = arg[1]\\n    return 0\\n    end\\\,\\n} -- code --\\nlocal data = 10\\nlocal Statement = g_Select.New()\\nStatement:Select (data\\\,choice) ()\\nprint(Statement.result)\\n-------------------------]]--\\n\\nlocal g_Select = {\\n  New = function ()\\n    local obj = {\\n      result = ''\\\,\\n      Select = function ( ... )\\n        local this   = arg[1]\\n        local case   = arg[2]\\n        local select = arg[3]\\n        if (select[case] ~= nil) then\\n          this.result = select[case]\\n        else\\n          this.result = select['default']\\n        end -- test (case)\\n        return this.result\\n        end\\\, -- Select () --\\n    } -- obj {} -- \\n    return obj \\n    end\\\, -- New () --\\n} -- g_Select {} --\\n\\nLUA = { -- LUA object \\n  New = function ( ... ) -- LUA Constructor\\n    local obj = {      \\n      LUALibrary = {\\n        ['are_conditions_met']            = 'current.AreConditionsMet'\\\,\\n        ['band_add_segment_segment']      = 'band.AddBetweenSegments'\\\,\\n        ['band_delete']                   = 'function ( ... ) if arg[2] then local N = \\\#arg for i=1\\\,N do band.Delete (arg[i]) end else band.DeleteAll () end end'\\\,\\n        ['band_disable']                  = 'function ( ... ) if arg[2] then local N = \\\#arg for i=1\\\,N do band.Disable (arg[i]) end else band.DisableAll () end end'\\\,\\n        ['band_enable']                   = 'function ( ... ) if arg[2] then local N = \\\#arg for i=1\\\,N do band.Enable (arg[i]) end else band.EnableAll () end end'\\\,\\n        ['band_set_length']               = 'band.SetGoalLength'\\\,\\n        ['band_set_strength']             = 'band.SetStrength'\\\,\\n        ['deselect_all']                  = 'selection.DeselectAll'\\\,\\n        ['deselect_index']                = 'function ( ... ) if arg[1] then local N = \\\#arg for i=1\\\,N do selection.Deselect (arg[i]) end else selection.DeselectAll () end end'\\\,\\n        ['do_freeze']                     = 'function ( ... ) if selection.GetCount() then freeze.FreezeSelected (true\\\,true) else freeze.FreezeAll () end end'\\\,\\n        ['do_global_wiggle_all']          = 'function ( ... ) local do_global_wiggle_all = structure.WiggleAll do_global_wiggle_all (arg[1]\\\,true\\\,true) end'\\\,\\n        ['do_global_wiggle_backbone']     = 'function ( ... ) local do_global_wiggle_backbone = structure.WiggleAll do_global_wiggle_backbone (arg[1]\\\,true\\\,false) end'\\\,\\n        ['do_global_wiggle_sidechains']   = 'function ( ... ) local do_global_wiggle_sidechains = structure.WiggleAll do_global_wiggle_sidechains (arg[1]\\\,false\\\,true) end'\\\,\\n        ['do_local_rebuild']              = 'structure.RebuildSelected'\\\,\\n        ['do_local_wiggle']               = 'function ( ... ) if selection.GetCount () then structure.LocalWiggleSelected (arg[1]\\\,true\\\,true) else structure.LocalWiggle (arg[1]\\\,true\\\,true) end end'\\\,\\n        ['do_mutate']                     = 'function ( ... ) if selection.GetCount () then structure.MutateSidechainsSelected (arg[1]) else structure.MutateSidechains (arg[1]) end end'\\\,\\n        ['do_shake']                      = 'function ( ... ) if selection.GetCount () then structure.ShakeSidechainsSelected (arg[1]) else structure.ShakeSidechainsAll (arg[1]) end end'\\\,\\n        ['do_sidechain_snap']             = 'rotamer.SetRotamer'\\\,\\n        ['do_unfreeze_all']               = 'freeze.UnfreezeAll'\\\,\\n        ['get_aa']                        = 'function ( ... ) local N = \\\#arg local lhs = {structure.GetAminoAcid (arg[1])} for i=2\\\,N do lhs[i] = structure.GetAminoAcid (arg[i]) end return lhs[2] ~= nil and lhs or lhs[1] end'\\\,\\n        ['get_band_count']                = 'band.GetCount'\\\,\\n        ['get_exploration_score']         = 'function ( ... ) return (current.GetEnergyScore () * current.GetExplorationMultiplier ()) end'\\\,\\n        ['get_platform']                  = 'ui.GetPlatform'\\\,\\n        ['get_ranked_score']              = 'function ( ... ) return current.GetScore () end'\\\,\\n        ['get_score']                     = 'function ( ... ) return current.GetScore () end'\\\,\\n        ['get_segment_count']             = 'structure.GetCount'\\\,\\n        ['get_segment_distance']          = 'structure.GetDistance'\\\,\\n        ['get_segment_score']             = 'function ( ... ) local N = \\\#arg local lhs = {current.GetSegmentEnergyScore (arg[1])} for i = 2\\\,N do lhs[i] = current.GetSegmentEnergyScore (arg[i]) end return lhs[2] ~= nil and lhs or lhs[1] end'\\\,\\n        ['get_segment_score_part']        = 'function ( ... ) local N = \\\#arg local lhs = {current.GetSegmentEnergySubscore (arg[2]\\\,arg[1])} for i = 3\\\,N do lhs [i-1] = current.GetSegmentEnergySubscore (arg[i]\\\,arg[1]) end return lhs[2] ~= nil and lhs or lhs[1] end'\\\,\\n        ['get_sidechain_snap_count']      = 'rotamer.GetCount'\\\,\\n        ['get_ss']                        = 'function ( ... ) local N = \\\#arg local lhs = {structure.GetSecondaryStructure (arg[1])} for i = 2\\\,N do lhs[i] = structure.GetSecondaryStructure (arg[i]) end return lhs[2] ~= nil and lhs or lhs[1] end'\\\,\\n        ['is_hydryphobic']                = 'function ( ... ) local N = \\\#arg local lhs = {structure.IsHydrophobic (arg[1])} for i = 2\\\,N do lhs[i] = structure.IsHydrophobic (arg[i]) end return lhs[2] ~= nil and lhs or lhs[1] end'\\\,\\n        ['load_structure']                = 'save.LoadSecondaryStructure'\\\,\\n        ['quickload']                     = 'save.Quickload'\\\,\\n        ['quicksave']                     = 'save.Quicksave'\\\,\\n        ['replace_aa']                    = 'function ( ... ) if selection.GetCount () then structure.SetAminoAcidSelected (arg[1]) else structure.SetAminoAcid (arg[1]\\\,arg[2]) end end'\\\,\\n        ['replace_ss']                    = 'function ( ... ) if selection.GetCount () then structure.SetSecondaryStructureSelected (arg[1]) else structure.SetSecondaryStructure (arg[1]\\\,arg[2]) end end'\\\,\\n        ['reset_puzzle']                  = 'puzzle.StartOver'\\\,\\n        ['reset_recent_best']             = 'recentbest.Save'\\\,\\n        ['restore_abs_best']              = 'recentbest.Save'\\\,\\n        ['restore_credit_best']           = 'creditbest.Restore'\\\,\\n        ['restore_recent_best']           = 'recentbest.Restore'\\\,\\n        ['save_structure']                = 'save.SaveSecondaryStructure'\\\,\\n        ['select_all']                    = 'selection.SelectAll'\\\,\\n        ['select_index']                  = 'function ( ... ) local N = \\\#arg selection.Select (arg[1]) for i=2\\\,N do selection.Select (arg[i]) end end'\\\,\\n        ['select_index_range']            = 'selection.SelectRange'\\\,\\n        ['set_behavior_clash_importance'] = 'behavior.SetClashImportance'\\\,\\n        }\\\, -- LUA.LUALibrary ()\\n      validationTool = function ( ... )  \\n        local function USE_API_VERSION_THREE ( ... )\\n          local this = arg[1]\\n          local code = arg[2]\\n          local lib = this.LUALibrary\\n          local body = code.body\\n          for i\\\,j in pairs ( lib ) do\\n            local api   = i\\n            local cbody = j\\n            body = body .. api .. ' = ' .. cbody .. '\\\\n'\\n          end -- loop\\n          return body\\n        end -- USE_API_VERSION_THREE ()\\n        local function USE_API_VERSION_TWO ( ... )\\n          local this   = arg[1]\\n          local code   = arg[2]\\n          local lib    = this.LUALibrary\\n          local body   = code.body\\n          local buffer = code.buffer\\n          local idx2   = \\\#code.buffer\\n          local cached = {}\\n          for idx=1\\\,idx2 do\\n            local api   = buffer [idx]\\n            local cbody = lib [ buffer [idx] ]\\n            if ( cbody and cached [api] == nil ) then\\n              cached [api] = true\\n              body = body .. api .. ' = ' .. cbody .. '\\\\n'\\n            end --  end if str\\n          end --  end loop\\n          return body\\n        end -- USE_API_VERSION_TWO ()\\n        local function USE_API_VERSION_ONE ( ... )\\n          local this = arg[1]\\n          local code = arg[2]\\n          return code.body\\n        end -- USE_API_VERSION_ONE ()\\n        local function BUILD_RECIPE ( ... )\\n          local version = arg[1]\\n          local code    = arg[2]\\n          local body    = arg[3]\\n          if ( version > API_VERSION.ONE ) then\\n            code.translated = code.header .. code.author .. body .. code.footer .. code.translated\\n          end\\n          return code\\n        end -- BUILD_RECIPE ()\\n        local function UPGRADE ( ... )\\n          local this    = arg[1]\\n          local code    = arg[2]\\n          local body    = code.body\\n          local version = ask.slider11.value\\n          local choice  = { -- codebody --\\n            [API_VERSION.TWO]   = USE_API_VERSION_TWO  \\\,\\n            [API_VERSION.THREE] = USE_API_VERSION_THREE\\\,\\n            ['default']         = USE_API_VERSION_ONE  \\\, -- *** required! *** --\\n          } -- choice {} --\\n          local Statement = g_Select.New()\\n          body = Statement:Select (version\\\,choice) (this\\\,code) -- test (slider 11)\\n          return BUILD_RECIPE ( version\\\,code\\\,body )\\n        end -- UPGRADE ()\\n        local this = arg[1]\\n        local code = arg[2]\\n        return UPGRADE ( this\\\,code )\\n        end\\\, -- LUA.validationTool ()\\n      tokenize = function ( ... ) \\n        local this = arg[1]\\n        local code = arg[2]\\n        local idx = 0\\n        local obj = {}\\n        string.gsub(code.buffer\\\,'[%w%_]+'\\\, -- perform string match on all keywords --\\n          function(v)\\n            idx = idx + 1 \\n            obj[idx] = tostring(v)\\n            return v\\n            end)\\n        return obj\\n        end\\\, -- LUA.tokenize ()\\n      translate = function ( ... ) \\n        local function CONTINUE_TRANSLATION ( ... )\\n          return (arg[1]==return_value.OK)\\n        end -- CONTINUE_TRANSLATION ()\\n        local this = arg[1]\\n        local __status__ = arg[2]\\n        if (CONTINUE_TRANSLATION (__status__) == false) then\\n          return\\n        end -- test (__status__)\\n        local buffer = g_Commandline or ask.srcCode.value\\n        local code = { \\n          buffer = buffer\\\, \\n          header = '--[[-----------------------------------------AUTO-GENERATED CODE-------------------------------------------]]-- \\\\n'\\\,  \\n          author = '-- ' .. g_author .. ' --\\\\n'\\\,\\n          body = ''\\\, \\n          footer = '--[[-------------------------------------------------------------------------------------------------------]]-- \\\\n\\\\n'\\\, \\n          translated  = buffer \\n        } -- code {}\\n        code.buffer = this:tokenize ( code )\\n        code = this:validationTool ( code )\\n        this:serialize ( code )\\n        end\\\, -- LUA.translate ()\\n      serialize = function ( ... )\\n        local this = arg[1]\\n        local code = arg[2]\\n        print ( code.translated )\\n        end\\\, -- LUA.serialize ()\\n    } -- obj{LUA}\\n    return obj\\n    end\\\, -- LUA.New ()\\n} -- LUA {} \\n\\nlocal function cleanup ( ... )\\n  print ('\\\\n' )\\n--print ( ' --  Done. --' )\\nend\\n\\nlocal function __main__ ( ... )\\n  local lua = LUA.New()\\n  lua:translate ( status )\\n  cleanup ()\\nend -- __main__ ()\\n\\nxpcall (__main__\\\,cleanup)\\n\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"2\"\n \"type\" : \"script\"\n \"uses\" : \"1\"\n \"ver\" : \"0.3\"\n}\n"
 "_recipe_959500702" : "{\n \"desc\" : \"Lua V2 with dialog\\\, good for filters and New Chapter\"\n \"folder_name\" : \"[Recipes]\"\n \"hidden\" : \"1\"\n \"mid\" : \"45315\"\n \"mrid\" : \"103774\"\n \"name\" : \"Total LWS V2.0\"\n \"parent\" : \"0\"\n \"parent_mrid\" : \"0\"\n \"player_id\" : \"447652\"\n \"script\" : \"--Total LWS V2.0\\r\\n--Based on Total LWS 1.0.4. by Rav3n_pl\\r\\n--Bruno Kestemont 6 Feb 2013\\r\\n--adapted to NC + minppi diminishes with loops 01/02/2014\\r\\n\\r\\n---------------------------------------------------------------------------------------\\r\\n--Generic parameters and functions\\r\\n\\r\\np=print --\\\"quicker\\\" print\\r\\nsegCnt=structure.GetCount()\\r\\n--runnum=1\\r\\n--minlen=1\\r\\n--maxlen=7\\r\\n--minppi=0.01\\r\\n--NotAllLoops=true\\r\\ntimeLeft=os.difftime(puzzle.GetExpirationTime()\\\,os.time())/86400\\r\\nstartTime=os.time()\\r\\nPROBABLEFILTER=false\\r\\nOriginalFilterSetting = behavior.GetSlowFiltersDisabled() -- new BK 8/4/2013\\r\\n\\r\\nfunction Score() \\r\\n\\treturn current.GetEnergyScore()\\r\\nend\\r\\n\\r\\nstartingscore= Score()\\r\\n\\r\\nfunction down1(x)--cut all afer 1-rd place\\r\\n    return x-x%0.1\\r\\nend\\r\\n\\r\\nfunction down(x)\\r\\n    return x-x%1\\r\\nend\\r\\n\\r\\nfunction detectfilter()\\r\\n\\tlocal descrTxt=puzzle.GetDescription()\\r\\n\\tif \\\#descrTxt>0 and (descrTxt:find(\\\"filter\\\") or descrTxt:find(\\\"filters\\\")) then\\r\\n\\t\\tPROBABLEFILTER=true\\r\\n\\tend\\r\\n\\treturn\\r\\nend\\r\\ndetectfilter()\\r\\n\\r\\nfunction AllLoop()\\r\\n\\tlocal ok=false\\r\\n                                                        -- First save structure !\\r\\n\\tfor i=1\\\, segCnt do\\r\\n\\t\\tlocal ss=structure.GetSecondaryStructure(i)\\r\\n\\t\\tif ss~=\\\"L\\\" then \\r\\n\\t\\t\\tsave.SaveSecondaryStructure()\\r\\n\\t\\t\\tok=true\\r\\n\\t\\t\\tbreak\\r\\n\\t\\tend\\r\\n\\tend\\r\\n\\tif ok then\\r\\n\\t\\tselection.SelectAll()\\r\\n\\t\\tstructure.SetSecondaryStructureSelected(\\\"L\\\")\\r\\n\\tend\\r\\nend\\r\\n\\r\\nfunction lw(minppi)\\r\\n\\tlocal gain=true\\r\\n\\twhile gain do\\r\\n\\t\\tlocal ss=Score()\\r\\n\\t\\tif PROBABLEFILTER then behavior.SetSlowFiltersDisabled(true) end-- new BK 8/4/2013\\\, always disable filter here\\r\\n\\t\\tstructure.LocalWiggleSelected(2) --structure.WiggleSelected\\r\\n\\t\\tif PROBABLEFILTER then behavior.SetSlowFiltersDisabled(OriginalFilterSetting) end -- new BK 8/4/2013\\\, always back to user settings\\r\\n\\t\\tlocal g=Score()-ss\\r\\n\\t\\tif g<minppi then gain=false end\\r\\n\\t\\tif g<0 then recentbest.Restore() end\\r\\n\\tend\\r\\n        selection.DeselectAll() -- new\\r\\n        freeze.UnfreezeAll() -- new\\r\\nend\\r\\n\\r\\n\\r\\n\\r\\n--Total lws\\r\\n\\r\\nfunction totalLws(minlen\\\,maxlen\\\,minppi)\\r\\n\\r\\n  local function Freeze(start\\\, len)\\r\\n\\tfreeze.UnfreezeAll()\\r\\n\\tselection.DeselectAll()\\r\\n\\tfor f=start\\\, segCnt\\\, len+1 do\\r\\n\\t\\tif f<= segCnt then selection.Select(f) end\\r\\n\\tend\\r\\n\\tfreeze.FreezeSelected(true\\\, false)\\r\\n  end\\r\\n\\r\\n  local function wiggle(start\\\,len\\\,minppi)\\r\\n\\tif start>1 then\\r\\n\\t\\tselection.DeselectAll()\\r\\n\\t\\tselection.SelectRange(1\\\,start-1)\\r\\n\\t\\tlw(minppi)\\r\\n\\tend\\r\\n\\tfor i=start\\\, segCnt\\\, len+1 do\\r\\n\\t\\tselection.DeselectAll()\\r\\n\\t\\tlocal ss = i+1\\r\\n\\t\\tlocal es=i+len\\r\\n\\t\\tif ss >= segCnt then ss=segCnt end\\r\\n\\t\\tif es >= segCnt then es=segCnt end\\r\\n\\t\\tselection.SelectRange(ss\\\,es)\\r\\n\\t\\tlw(minppi)\\r\\n\\tend\\r\\n  end\\r\\n\\r\\n  freeze.UnfreezeAll()\\r\\n  selection.DeselectAll()\\r\\n  behavior.SetClashImportance(1)\\r\\n  save.SaveSecondaryStructure()\\r\\n  if NotAllLoops==true then\\r\\n\\tAllLoop()\\r\\n  end\\r\\n  local ssc=Score()\\r\\n  p(\\\"Starting Total LWS: \\\"..ssc)\\r\\n\\tp(\\\"Lenght: \\\"..minlen..\\\" to \\\"..maxlen..\\\" ;minimum ppi: \\\"..minppi)\\r\\n  for l=minlen\\\, maxlen do\\r\\n\\t\\tfor s=1\\\, l+1 do\\r\\n\\t\\t\\tp(\\\"Len: \\\"..l..\\\"..start point: \\\"..s)\\r\\n\\t\\t\\tFreeze(s\\\,l)\\r\\n\\t\\t\\tlocal sp=Score()\\r\\n\\t\\t\\trecentbest.Save()\\r\\n\\t\\t\\twiggle(s\\\,l\\\,minppi)\\r\\n\\t\\t\\tlocal g=Score()-sp\\r\\n            p(\\\"Gained another: \\\"..g)\\r\\n\\t\\tend\\r\\n  end\\r\\n  p(\\\"Total LWS gain: \\\"..Score()-ssc)\\r\\n  save.LoadSecondaryStructure()\\r\\nend\\r\\n\\r\\nfunction AskOptions()\\r\\n\\tlocal ask=dialog.CreateDialog(\\\"TotalLWS options\\\")\\r\\n\\t--repeat\\r\\n\\t\\tif timeLeft<2 then\\r\\n\\t\\t\\task.minlen=dialog.AddSlider(\\\"min lenght\\\"\\\,1\\\,1\\\,3\\\,0)\\r\\n\\t\\t\\task.maxlen=dialog.AddSlider(\\\"max lenght\\\"\\\,7\\\,3\\\,15\\\,0)\\r\\n\\t\\t\\task.minppi=dialog.AddSlider(\\\"Min points per iteration\\\"\\\,0.01\\\,0.001\\\,0.3\\\,3)\\r\\n\\t\\t\\task.runnum=dialog.AddSlider(\\\"Number runs\\\"\\\,10\\\,1\\\,20\\\,0)\\r\\n\\t\\telseif Score()<5000 then--]]\\r\\n\\t\\t\\task.minlen=dialog.AddSlider(\\\"min lenght\\\"\\\,1\\\,1\\\,5\\\,0)\\r\\n\\t\\t\\task.maxlen=dialog.AddSlider(\\\"max lenght\\\"\\\,7\\\,5\\\,12\\\,0)\\r\\n\\t\\t\\task.minppi=dialog.AddSlider(\\\"Min points per iteration\\\"\\\,300\\\,100\\\,500\\\,-1)\\r\\n\\t\\t\\task.runnum=dialog.AddSlider(\\\"Number runs\\\"\\\,1\\\,1\\\,5\\\,0)\\t\\r\\n\\t\\telse\\r\\n\\t\\t\\task.minlen=dialog.AddSlider(\\\"min lenght\\\"\\\,1\\\,1\\\,6\\\,0)\\r\\n\\t\\t\\task.maxlen=dialog.AddSlider(\\\"max lenght\\\"\\\,7\\\,6\\\,12\\\,0)\\r\\n\\t\\t\\task.minppi=dialog.AddSlider(\\\"Min points per iteration\\\"\\\,0.1\\\,0.01\\\,3\\\,2)\\r\\n\\t\\t\\task.runnum=dialog.AddSlider(\\\"Number runs\\\"\\\,1\\\,1\\\,5\\\,0)\\r\\n\\t\\tend\\r\\n\\t\\task.NotAllLoops = dialog.AddCheckbox(\\\"Keep structure\\\"\\\,true)\\r\\n\\t\\task.OK = dialog.AddButton(\\\"OK\\\"\\\,1) ask.Cancel = dialog.AddButton(\\\"Cancel\\\"\\\,0)\\r\\n\\t\\taskresult=dialog.Show(ask)\\r\\n\\t--until askresult<2\\r\\n\\t--return askresult > 0\\r\\n\\t--end\\r\\n\\t\\r\\n\\tif askresult > 0 then\\r\\n\\t\\tminlen=ask.minlen.value -- minimum lenggh of sgmnts - if you have done lws by 1 and 2 you may want set it to 3\\r\\n\\t\\tmaxlen=ask.maxlen.value --segCntmum lenght of sgments - more than 7 looks useless\\r\\n\\t\\tminppi=ask.minppi.value --minimum gain per local wiggle iter\\r\\n\\t\\trunnum=ask.runnum.value\\r\\n\\t\\tNotAllLoops=ask.NotAllLoops.value\\r\\n        print(\\\"Options:minlen =\\\"\\\,minlen\\\,\\\"\\\, maxlen =\\\"\\\,maxlen\\\,\\\"\\\, minppi =\\\"\\\,minppi\\\, \\\"\\\, runnum =\\\"\\\,runnum\\\, \\\"\\\, NotAllLoops =\\\"\\\,NotAllLoops)\\t\\t\\r\\n\\t    return true\\r\\n    end\\r\\n    return false\\r\\nend\\r\\n\\r\\nif AskOptions()==false then\\r\\n    return\\r\\nend\\r\\n\\r\\n--M A I N -----\\r\\n\\r\\n--AskOptions()\\r\\n\\r\\nwhile(true) do\\r\\n\\tfor i=1\\\, runnum do\\r\\n\\t\\tprint(\\\"run \\\"..i..\\\" / \\\"..runnum)\\r\\n\\t\\ttotalLws(minlen\\\,maxlen\\\,minppi)\\r\\n\\t\\tminppi=minppi*(1-(1/runnum)) -- new 01/02/2014\\r\\n\\tend\\r\\nend\\r\\n--recipe.ReportStatus()\\r\\nduration=(os.time()-startTime)/60 -- in minutes\\r\\nscore=Score()\\r\\nRecipegain=score-startingscore\\r\\nRecipeReturn=Recipegain/duration*60 -- in pts/hour\\r\\nprint(\\\"Duration = \\\"..down(duration)..\\\" min. Return= \\\"..down1(RecipeReturn)..\\\" pts/hour.\\\")\\r\\n\\r\\n\"\n \"script_version\" : \"2\"\n \"share_scope\" : \"3\"\n \"type\" : \"script\"\n \"uses\" : \"0\"\n \"ver\" : \"0.3\"\n}\n"
}
verify: ada63da25b8e460c2cbe6cf93da587a3
